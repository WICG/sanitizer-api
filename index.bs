<pre class="metadata">
Title: HTML Sanitizer API
Status: CG-DRAFT
Group: WICG
URL: https://wicg.github.io/sanitizer-api/
Repository: WICG/sanitizer-api
Shortname: sanitizer-api
Level: 1
Editor: Frederik Braun 68466, Mozilla, fbraun@mozilla.com, https://frederik-braun.com
Editor: Mario Heiderich, Cure53, mario@cure53.de, https://cure53.de
Editor: Daniel Vogelheim, Google LLC, vogelheim@google.com, https://www.google.com
Abstract:
  This document specifies a set of APIs which allow developers to take
  untrusted HTML input and sanitize it for safe insertion into a document's
  DOM.
Indent: 2
Work Status: exploring
Boilerplate: omit conformance
Markup Shorthands: css off, markdown on
WPT Display: inline
WPT Path Prefix: /sanitizer-api/
</pre>
<pre class="anchors">
text: innerHTML; type: attribute; for: Element; url: https://dom.spec.whatwg.org/#widl-Element-innerHTML
text: window.toStaticHTML(); type: method; url: https://msdn.microsoft.com/en-us/library/cc848922(v=vs.85).aspx
text: createDocumentFragment; type: method; url: https://dom.spec.whatwg.org/#dom-document-createdocumentfragment
</pre>
<pre class="biblio">
{
  "DOMPURIFY": {
    "href": "https://github.com/cure53/DOMPurify",
    "title": "DOMPurify",
    "publisher": "Cure53"
  },
  "MXSS": {
    "href": "https://cure53.de/fp170.pdf",
    "title": "mXSS Attacks: Attacking well-secured Web-Applications by using innerHTML Mutations",
    "publisher": "Ruhr-Universität Bochum"
  },
  "MXSS1": {
    "href": "https://research.securitum.com/mutation-xss-via-mathml-mutation-dompurify-2-0-17-bypass/",
    "title": "Mutation XSS via namespace confusion"
  },
  "MXSS2": {
    "href": "https://www.checkmarx.com/blog/technical-blog/vulnerabilities-discovered-in-mozilla-bleach/",
    "title": "CVE-2020-6802 Write-up"
  },
  "DEFAULTS": {
    "href": "https://github.com/WICG/sanitizer-api/blob/main/resources/defaults-derivation.html",
    "title": "Sanitizer API Defaults"
  }
}
</pre>

# Introduction # {#intro}

<em>This section is not normative.</em>

Web applications often need to work with strings of HTML on the client side,
perhaps as part of a client-side templating solution, perhaps as part of
rendering user generated content, etc. It is difficult to do so in a safe way,
however; the naive approach of joining strings together and stuffing them into
an {{Element}}'s {{Element/innerHTML}} is fraught with risk, as that can and
will cause JavaScript execution in a number of unexpected ways.

Libraries like [[DOMPURIFY]] attempt to manage this problem by carefully
parsing and sanitizing strings before insertion by constructing a DOM and
walking its members through an allow-list. This has proven to be a fragile
approach, as the parsing APIs exposed to the web don't always map in
reasonable ways to the browser's behavior when actually rendering a string as
HTML in the "real" DOM. Moreover, the libraries need to keep on top of
browsers' changing behavior over time; things that once were safe may turn
into time-bombs based on new platform-level features.

The browser has a fairly good idea of when it is going to
execute code. We can improve upon the user-space libraries by teaching the
browser how to render HTML from an arbitrary string in a safe manner, and do
so in a way that is much more likely to be maintained and updated along with
the browser's own changing parser implementation. This document outlines an
API which aims to do just that.

## Goals ## {#goals}

*   Mitigate the risk of DOM-based cross-site scripting attacks by providing
    developers with mechanisms for handling user-controlled HTML which prevent
    direct script execution upon injection.

*   Make HTML output safe for use within the current user agent, taking into
    account its current understanding of HTML.

*   Allow developers to override the defaults set of elements and attributes.
    Adding certain elements and attributes can prevent
    <a href="https://github.com/google/security-research-pocs/tree/master/script-gadgets">script gadget</a>
    attacks.

## API Summary ## {#api-summary}

<div class="example">
```js
let s = new Sanitizer();

// Case: The input data is available as a tree of DOM nodes.
let userControlledTree = ...;
element.replaceChildren(s.sanitize(userControlledTree));

// Case: The input is available as a string, and we know the element to insert
// it into:
let userControlledInput = "&lt;img src=x onerror=alert(1)//&gt;";
element.setHTML(userControlledInput, s);

// Case: The input is available as a string, and we know which type of element
// we will eventually insert it to, but can't or don't want to perform the
// insertion now:
let forDiv = s.sanitizeFor("div", userControlledInput);
// Later:
document.querySelector(\`${forDiv.localName}#target\`).replaceChildren(forDiv.children);
```
</div>

## The Trouble With Strings ## {#strings}

Many HTML sanitizer libraries are based on string-to-string APIs, while this
API does not offer such a method directly. This sub-section explains the
reasons and implications for the Sanitizer API.

To convert a string into a tree of nodes (or a fragment), it needs to be parsed.
The [HTML parsing algorithm](https://html.spec.whatwg.org/multipage/parsing.html#parsing)
carefully specifies how parsing HTML works. This parsing algorithm is dependent
on the current node as its parsing context. That is, the same string parsed
in the context of different HTML nodes will yield different parse trees.

<div class="example">
The string `<em>bla` in `<div>` and `<textarea>` context.
  * `<div><em>bla</div>` &#8680; `<div><em>bla</em></div>`
  * `<textarea><em>bla</textarea>` &#8680; `<textarea>&lt;em&gt;bla</textarea>`
</div>

<div class="example">
A table cell in `<table>` and non-table (`<div>`) context.
  * `<table><td>text</table>` &#8680; `<table><td>text</table>`
  * `<div><td>text</div>`  &#8680; `<div>text</div>`
</div>

These differences can allow bugs to creep into a site's sanitization strategy,
which can (and have been) exploited by a class of XSS-style attacks called mXSS.
These attacks ultimately depend on confusions of the parsing context, for
example when a developer will sanitize a string in one (parsing) context,
while then applying the resulting string in a different context, where it will
be interpreted differently.

<div class="example">
  Two mXSS-style examples in real-world libraries can be found in
  [[MXSS1]]] and [[MXSS2]]. We'd like to stress that we picked these reports
  for their ease of reading. There are similar reports for pretty much every
  other tools that deals with HTML parsing.
</div>

Since this attack class depends on a particular usage of the string *after*
the sanitization has occurred, the API itself has only limited capability
to protect its users. As a result, the Sanitizer API follows the following
principle:

Whenever the Sanitzer API parses or unparses a DOM (sub-)tree to or from a
string, it will either do so in a fashion where the correct parse context is
implied by the operation; or it will require a parse context to be supplied by
the developer and will retain the given context in the resulting argument.
In other words, the Sanitzer API will never assume a parsing context, or
disappear a parsing context that has been supplied earlier.

### Case 1: Sanitizing With Nodes, Only. ### {#string-context-case-1}

If the user data in question is already available as DOM nodes - for example
a {{Document}} instance in a frame - then the Sanitizer can be easily used:

<div class="example">
```js
const sanitizer = new Sanitizer( ... );  // Our Sanitizer;

// There is an iframe with id "userFrame", whose content we are interested in.
const user_tree = document.getElementById("userFrame").contentWindow.document;
const sanitized = sanitizer.sanitize(user_tree);
```
</div>

Note: Parsing an HTML string can have various side-effects, like network
  requests or executing scripts. Naively parsing these, e.g. by assigning a
  string to `.innerHTML` of an unconnected element, will not reliably prevent
  these. Therefore, if the user data to be sanitized is originally
  in string form, we recommend to go with one of the following cases.

### Case 2: Sanitizing a String with Implied Context. ### {#string-context-case-2}

If the user data is available in string form and we wish to
directly insert the sanitized subtree into the DOM, we can do so as follows:

<div class="example">
```js
const user_string = "...";  // The user string.
const sanitizer = new Sanitizer( ... );  // Our Sanitizer;

// We want to insert the HTML in user_string into a target element with id
// target. That is, we want the equivalent of target.innerHTML = value, except
// without the XSS risks.
document.getElementById("target").setHTML(user_string, sanitizer);
```
</div>

### Case 3: Sanitizing a String with a Given Context. ### {#string-context-case-3}

If the user data is available in string form and the developer wishes to
sanitize it now, but apply the result to the DOM later, then the Sanitizer
must be informed about the context that it will be used. To prevent context
confusion the result is wrapper a container that contains both the
result and also the parse context. Conveniently, this container already
exists, and it is the node itself!

<div class="example">
```js
// A certain piece of user input is meant to be used repeatedly, to insert
// it in multiple elements on the page. All these elements will be <div>
// elements.
const user_string = "...";  // The user string.
const sanitizer = new Sanitizer( ... );  // Our Sanitizer.

const sanitized = sanitizer.sanitizeFor("div", user_string);
sanitized instanceof HTMLDivElement  // true. The Sanitizer has given us a node.

// ... later, in the same program ...
for (let elem = ... of ...) {
  // All of our "elem" instances should be of the same type used in the
  // .sanitizeFor call above. With an assertion library, this could look as
  // follows:
  assert_true(elem instanceof sanitized.constructor);  // Assuming assert_true, like in WPT tests.
  elem.replaceChildren(sanitized.children);
}

// Instead of:
elem.replaceChildren(sanitized.children);
// one could write:
elem.innerHTML = sanitized.innerHTML;
// This should have the same effect, except be slower, since this will trigger
// un-parsing and then re-parsing the node tree which we already have
// available as a node tree. So we recommend to stick with the former version.
```
</div>

### The Other Case ### {#string-context-case-other}

What if neither of these cases works with a given application structure, and a
string-to-string operation is required? In this case, the developer is free to
take the sanitization result and remove it from its context. In this case, the
responsibility to prevent mXSS-class attacks that stem from mis-applying those
strings in an inappropriate context remains with the developer.

<div class="example">
```js
const user_string = "...";  // The user string.
const sanitizer = new Sanitizer( ... );  // Our Sanitizer.

// The developer plans to insert this string into a <div> element, but has to
// keep this around as a string (instead of an element). It's important that
// the developer remembers the parsing context and MUST NOT use this in a
// different parsing context in order to prevent mXSS attacks.
const sanitized_for_div = sanitizer.sanitizeFor("div", user_string).innerHTML;
```
</div>

# Framework # {#framework}

## Sanitizer API ## {#sanitizer-api}

The core API is the `Sanitizer` object and the sanitize method. Sanitizers can
be instantiated using an optional `SanitizerConfig` dictionary for options.
The most common use-case - preventing XSS - is handled by default,
so that creating a Sanitizer with a custom config is necessary only to
handle additional, application-specific use cases.

<pre class="idl">
  [
    Exposed=(Window),
    SecureContext
  ] interface Sanitizer {
    constructor(optional SanitizerConfig config = {});

    DocumentFragment sanitize((Document or DocumentFragment) input);
    Element? sanitizeFor(DOMString element, DOMString input);

    SanitizerConfig getConfiguration();
    static SanitizerConfig getDefaultConfiguration();
  };
</pre>

* The <dfn constructor for=Sanitizer lt="Sanitizer(config)">
    <code>new Sanitizer(<var>config</var>)</code></dfn> constructor steps
    are to run the [=create a sanitizer=] algorithm steps with |config| as
    parameter.
* The <dfn method for=Sanitizer><code>sanitize(<var>input</var>)</code></dfn>
    method steps are to return the result of running the [=sanitize=]
    algorithm on |input|,
* The <dfn method for=Sanitizer><code>sanitizeFor(<var>element</var>, <var>input</var>)</code></dfn>
    method steps are to return the result of running [=sanitizeFor=]
    algorithm on |element| and |input|.
* The <dfn method for=Sanitizer><code>getConfiguration()</code></dfn> method steps are
    to return the result of running the [=query the sanitizer config=]
    algorithm. It essentially returns a copy of the Sanitizer's
    [=configuration object=], with some degree of normalization.
* The value of the static
    <dfn method for=Sanitizer><code>getDefaultConfiguration()</code></dfn> method steps
    are to return the value of the [=default configuration=] object.

The {{Element}} interface gains an additional method, `setHTML` which
applies a string using a Sanitzer directly to an existing element node.

<pre class="idl">
  partial interface Element {
    undefined setHTML(DOMString input, Sanitizer sanitizer);
  };
</pre>

* The <dfn method for=Element><code>setHTML(<var>input</var>, <var>sanitizer</var>)</code></dfn>
  method steps are to run the [=sanitizeAndSet=] algorithm on |input| and
  |sanitizer|.

Issue: Is this how we specify a method on existing class "owned" by a different spe?

<div class="example">
```js
  // To make our examples easy to follow, we'll need a way create DOM nodes.
  // The following is hacky way to accomplish this, for illustration only,
  // that you shall pretty please not use in practice. This parsing method can
  // cause side-effects based on the string being parsed, which is insecure.
  // In fact, this very API exists for the sole purpose of preventing the
  // problems that this approach has.
  //
  // But... for our examples we'll need something that is quick and easy, since
  // we cannot use our own Sanitizer API to demo our own Sanitizer API...
  const to_node = str => (new DOMParser).parseFromString(str, "text/html").body.firstChild;

  // The core API of the Sanitizer is the .sanitize method:
  let untrusted_input = to_node("Hello!");
  const sanitizer = new Sanitizer();
  sanitizer.sanitize(untrusted_input);  // DocumentFragment w/ a text node, "Hello!"

  // Probably we want to put this somewhere in our DOM:
  element.replaceChildren(sanitizer.sanitize(untrusted_input));

  // If our input contains markup it'll be mostly preserved, except for
  // script-y markup:
  untrusted_input = to_node("<em onclick='alert(1);'>Hello!</em>");
  sanitizer.sanitizer(untrusted_input);  // <em>Hello!</em>
  element.replaceChildren(sanitizer.sanitize(untrusted_input));  // No alert!

  // The .sanitize method is the primary API, and returns a DocumentFragment.
  // The .sanitizeFor method accepts and parses a string and returns an HTML
  // element node.
  const hello = to_node("hello");
  (sanitizer.sanitize(hello))) instanceof DocumentFragment;  // true
  (sanitizer.sanitizeFor("template", "hello") instanceof HTMLTemplateElement;  // true
```
</div>

## String Handling ## {#api-string-handling}

Parsing (and unparsing) strings to (or from) HTML requires a context element.
Thus, the `sanitizeFor` method requires us to pass in a context, which we can
in turn hand over to the HTML Parser.

Additionally, the {{Element}} interface gains a `setHTML` method, which
always knows the correct context, because it is applied to a given {{Element}}
instance. This {{Element}} is the correct context for both parsing and
unparsing its own content.

One way to conceptualize this is to view string sanitization as a three step
operation: 1, parsing the string; 2, sanitizing the resulting node tree;
and 3, grafting the resulting subtree onto our live DOM.
`Sanitizer.sanitize` is the middle step.
`Sanitizer.sanitizeFor` performs the first and second steps, but leaves the
third to the developer. `Element.setHTML` does all three. Which to use
depends on the structure of your application, whether you can do all three
steps simultaneously, or whether maybe the sanitization is removed (in either
code structure or point in time) from the eventual modification of the DOM.

<div class="example">
```js
  // If the markup to be sanitized is already available as a tree, for example
  // from an embedded frame, one can use sanitize:
  document.getElementById("target").replaceChildren(
    sanitizer.sanitize(
      document.querySelector("iframe#myframe").contentWindow.document.body));

  // If the markup to be sanitized is present in string form, but we already
  // have the element we want to insert in available:
  const untrusted_input = "....";
  document.getElementById("someelement").setHTML(untrusted_input, sanitizer);

  // If the markup to be sanitized is present in string form, but we don't want
  // to do the DOM insertion now:
  let no_xss = sanitizer.sanitizeFor("dic", untrusted_input);
  // ... much later ...
  document.querySelector("div#targetdiv").replaceChildren(no_xss.children);

  // Note that parsing HTML depends on the current context in many ways, some
  // subtle, some not so much. Supplying a different context than what the
  // result will eventually be used in has both security and functional risks.
  // It's up to the developer to handle this safely.
  //
  // Example: Most, many parsing contexts disallow table  data (<td>) without
  //          an enclosing table.
  sanitizer.sanitizeFor("div", "<td>data</td>").innerHTML  // "data"
  sanitizer.sanitizeFor("table", "<td>data</td>").innerHTML  // "<td>data</td>"
```
</div>

<div class="note">
Note: Sanitizing a string will use the [=HTML Parser=] to parse the input,
which will perform some degree of normalization. So even
if no sanitization steps are taken on a particular input, it cannot be
guaranteed that the output of `.sanitizeToString` will be
character-for-character identical to the input.

<div class="example">
    ```js
    sanitizer.sanitizeFor("div", "Stra&szlig;e")  // Straße
    sanitizer.sanitizeFor("div", "<image>")  // <img>
    ```
</div>
</div>

<div class="note">
Note: `Sanitizer.sanitizeFor` and `Element.setHTML` can replace the
    respective other. Both are provided, since they support different use cases.

<div class="example">
    ```js
    // sanitizeFor, based on SetInnerHTML.
    function sanitizeFor(element, input) {
      const elem = document.createElement(element);
      elem.setHTML(input, this);
      return elem;
    }

    // setHTML, based on sanitizeFor.
    function setHTML(input, sanitizer) {
      this.replaceChildren(sanitizer.sanitizeFor(this.localName, input).children);
    }
    ```
</div>
</div>

## The Configuration Dictionary ## {#config}

The Sanitizer's <dfn>configuration object</dfn> is a dictionary which
describes modifications to the sanitize operation. If a Sanitizer has
not received an explicit configuration, for example when being
constructed without any parameters, then the [=default configuration=] value
is used as the configuration object.

<pre class="idl">
  dictionary SanitizerConfig {
    sequence&lt;DOMString> allowElements;
    sequence&lt;DOMString> blockElements;
    sequence&lt;DOMString> dropElements;
    AttributeMatchList allowAttributes;
    AttributeMatchList dropAttributes;
    boolean allowCustomElements;
    boolean allowComments;
  };
</pre>

: allowElements
:: The <dfn>element allow list</dfn> is a sequence of strings with
    elements that the sanitizer should retain in the input.
: blockElements
:: The <dfn>element block list</dfn> is a sequence of strings with elements
   where the sanitizer should remove the elements from the input, but retain
   their children.
: dropElements
:: The <dfn>element drop list</dfn> is a sequence of strings with elements
   that the sanitizer should remove from the input, including its children.
: allowAttributes
:: The <dfn>attribute allow list</dfn> is an [=attribute match list=], which
   determines whether an attribute (on a given element) should be allowed.
: dropAttributes
:: The <dfn>attribute drop list</dfn>  is an [=attribute match list=], which
   determines whether an attribute (on a given element) should be dropped.
: allowCustomElements
:: The <dfn>allow custom elements option</dfn> determines whether
   [=custom elements=] are to be considered. The default is to drop them.
   If this option is true, custom elements will still be checked against all
   other built-in or configured checks.
: allowComments
:: The <dfn>allow comments option</dfn> determines whether HTML comments are
   allowed.

Note: `allowElements` creates a sanitizer that defaults to dropping elements,
  while `blockElements` and `dropElements` defaults to keeping unknown
  elements. Using both types is possible, but is probably of little practical
  use. The same applies to `allowAttributes` and `dropAttributes`.

Note: Element names are normalized, following the rules of the HTML Parser.
  This means elements are usually lowercase, except for a small-ish number
  of mixed case element names in non-HTML namespaces (SVG, MathML).

<div class="example">
```js
  const sample = "Some text <b><i>with</i></b> <blink>tags</blink>.";

  // Some text <b>with</b> text tags.
  new Sanitizer({allowElements: [ "b" ]}).sanitize(sample);

  // Some text <i>with</i> <blink>tags</blink>.
  new Sanitizer({blockElements: [ "b" ]}).sanitize(sample);

  // Some text <blink>tags</blink>.
  new Sanitizer({dropElements: [ "b" ]}).sanitize(sample);

  // Note: The default configuration handles XSS-relevant input:

  // Non-scripting input will be passed through:
  new Sanitizer().sanitize(sample);  // Will output sample unmodified.

  // Scripts will be blocked: "abc alert(1) def"
  new Sanitizer().sanitize("abc <script>alert(1)</script> def");
```
</div>

In addition to allow and block lists for elements and attributes, there are
also options to configure some node or element types.

Examples:
```js
  // Comments will be dropped by default.
  const comment = to_node("Hello <!-- comment --> World!");
  new Sanitizer().sanitize(comment);  // "Hello  World!"
  new Sanitizer({allowComments: true}).sanitize(comment);  // Same as comment.
```

A sanitizer's configuration can be queried using the
[=query the sanitizer config=] method.

<div class="example">
```js
  // Does the default config allow script elements?
  Sanitizer.getDefaultConfiguration().allowElements.includes("script")  // false

  // We found a Sanitizer instance. Does it have an allow-list configured?
  const a_sanitizer = ...;
  !!a_sanitizer.getConfiguration().allowElements // true, if an allowElements list is configured

  // If it does have an allow elements list, does it include the <div> element?
  a_sanitizer.getConfiguration().allowElements.includes("div")  // true, if "div" is in allowElements.

  // Note that the getConfiguration method might do some normalization. E.g., it won't
  // contain key/value pairs that are not declare in the IDL.
  Object.keys(new Sanitizer({madeUpDictionaryKey: "Hello"}).getConfiguration())  // []

  // As a Sanitizer's config describes its operation, a new sanitizer with
  // another instance's configuration should behave identically.
  // (For illustration purposes only. It would make more sense to just use a directly.)
  const a = /* ... a Sanitizer we found somewhere ... */;
  const b = new Sanitizer(a.getConfiguration());  // b should behave the same as a.

  // getDefaultConfiguration() and new Sanitizer().getConfiguration should be the same.
  // (For illustration purposes only. There are better ways of implementing
  // object equality in JavaScript.)
  JSON.stringify(Sanitizer.getDefaultConfiguration()) == JSON.stringify(new Sanitizer().getConfiguration());  // true

  // Element names are normalized.
  new Sanitizer({allowElements: ["EM", "sPAn"]}).config().allowElements  // ["em", "span"]
```
</div>

### Attribute Match Lists ### {#attr-match-list}

An <dfn>attribute match list</dfn> is a map of attribute names to element names,
where the special name "*" stands for all elements. A given |attribute|
belonging to an |element| matches an [=attribute match list=], if the
attribute's [=Attr/local name=] is a key in the match list, and element's
[=Element/local name=] or `"*"` are found in the attribute's value list.

<pre class="idl">
  typedef record&lt;DOMString, sequence&lt;DOMString>> AttributeMatchList;
</pre>

<div class="example">
Examples for attributes and attribute match lists:
```js
  const sample = "<span id='span1' class='theclass' style='font-weight: bold'>hello</span>";

  // Allow only <span style>: <span style='font-weight: bold'>...</span>
  new Sanitizer({allowAttributes: {"style": ["span"]}}).sanitize(sample);

  // Allow style, but not on span: <span>...</span>
  new Sanitizer({allowAttributes: {"style": ["div"]}}).sanitize(sample);

  // Allow style on any elements: <span style='font-weight: bold'>...</span>
  new Sanitizer({allowAttributes: {"style": ["*"]}}).sanitize(sample);

  // Drop <span id>: <span class='theclass' style='font-weight: bold'>...</span>
  new Sanitizer({dropAttributes: {"id": ["span"]}}).sanitize(sample);

  // Drop id, everywhere: <span class='theclass' style='font-weight: bold'>...</span>
  new Sanitizer({dropAttributes: {"id": ["*"]}}).sanitize(sample);
```
</div>

# Algorithms # {#algorithms}

## API Implementation ## {#api-algorithms}

<div algorithm="create a sanitizer">
To <dfn>create a Sanitizer</dfn> with an optional |config| parameter, run
these steps:
  1. Let |sanitizer| be a newly created Sanitizer instance.
  1. Create a copy of |config|.
  1. Normalize all element names in |config|'s copy by running the
     [=normalize element name=] algorithm on each of them.
  1. Return |sanitizer|, with |config|'s copy as its [=configuration object=].
</div>

Note: The configuration object contains element names in the
  [=element allow list=], [=element block list=], and [=element drop list=], and
  in the mapped values in the [=attribute allow list=] and [=attribute drop list=].

<div algorithm="normalize element name">
To <dfn>normalize element name</dfn> |name|, run these steps:
  1. Convert |name| to [=ASCII lowercase=].
  1. Return |name|.

<div class="issue">
This method will not work for SVG and/or MathML elements, which are not
  currently supported. When they are, replace the steps above with:

  1. Convert |name| to [=ASCII lowercase=].
  1. Let |prefix| be the empty string.
  1. If |name| contains a ":" (U+003E), then split the string on it and
     set |prefix| to the part before, and update |name| with the part after.
  1. If |prefix| is either "svg" or "math", then adjust the name as described
     in the "any other start tag" branch of the
     [The rules for parsing tokens in foreign content](https://html.spec.whatwg.org/multipage/parsing.html#parsing-main-inforeign)
     subchapter in the HTML parsing spec.
  1. Return |name|.
</div>

</div>

<div algorithm="sanitize">
To <dfn>sanitize</dfn> a given |input| of type `Document or DocumentFragment`
run these steps:
  1. Let |fragment| be the result of running the [=create a document fragment=]
     algorithm on |input|.
  1. Run the [=sanitize a document fragment=] algorithm on |fragment|.
  1. Return |fragment|.
<wpt>
  sanitizer-sanitize.https.tentative.html
</wpt>
</div>

<div algorithm="sanitizeFor">
To <dfn lt="sanitizeFor">sanitize for</dfn> an |element| name of type
|DOMString| and a given |input| of type |DOMString| run these steps:
  1. Let |node| be an HTML element created by running the steps
     of the [=creating an element=] algorithm with the current document,
     |element|, the [[HTML namespace]], and no optional parameters.
  1. If the the result of running the steps of the
     [=determine the baseline configuration for an element=] algorithm
     for the element |node| is anything other than `keep`, then return
     `null`.
  1. Let |fragment| be the result of invoking the
     [html fragment parsing algorithm](https://w3c.github.io/DOM-Parsing/#dfn-fragment-parsing-algorithm),
     with |node| as the `context element` and |input| as `markup`.
  1. Run the steps of the [=sanitize a document fragment=] algorithm on |fragment|.
  1. [=Replace all=] with |fragment| as the `node` and |node| as the `parent`.
  1. Return |node|.
<wpt>
  sanitizer-sanitizeFor.https.tentative.html
</wpt>
</div>

<div algorithm="sanitizeAndSet">
To <dfn lt="sanitizeAndSet">sanitize and set</dfn> a |value| using a
{{Sanitizer}} |sanitizer| on an {{Element}} node |this|, run these steps:
  1. If the the result of running the steps of the
     [=determine the baseline configuration for an element=] algorithm
     for the element |this| is anything other than `keep`, then throw a
     {{TypeError}} and return.
  1. Let |fragment| be the result of invoking the
     [html fragment parsing algorithm](https://w3c.github.io/DOM-Parsing/#dfn-fragment-parsing-algorithm)
     with |this| as the `context node` and |value| as `markup`.
  1. Run the steos if the [=sanitize a document fragment=] algorithm
     on |fragment|, using |sanitizer| as the current {{Sanitizer}} instance.
  1. [=Replace all=] with |fragment| as the `node` and |this| as the `parent`.
<wpt>
  element-set-sanitized-html.https.tentative.html
</wpt>
</div>

<div algorithm="query the sanitizer config">
To <dfn>query the sanitizer config</dfn> of a given sanitizer instance,
run these steps:
  1. Let |sanitizer| be the current Sanitizer.
  1. Let |config| be |sanitizer|'s [=configuration object=], or the
     [=default configuration=] if no [=configuration object=] was given.
  1. Let |result| be a newly constructed SanitizerOptions dictionary.
  1. For any non-empty member of |config| whose key is declared in
     SanitizerOptions, copy the value to |result|.
  1. Return |result|.
<wpt>
  sanitizer-config.https.tentative.html
  sanitizer-query-config.https.tenative.html
</wpt>
</div>

## Helper Definitions ## {#helper-algorithms}

<div algorithm="create a document fragment">
To <dfn>create a document fragment</dfn> named |fragment| from an
|input| of type `Document or DocumentFragment`, run these steps:

  1. Switch based on |input|'s type:
    1. If |input| is of type {{DocumentFragment}}, then:
      1. Let |node| refer to |input|.
    1. If |input| is of type {{Document}}, then:
      1. Let |node| refer to |input|'s `documentElement`.
  1. Let |clone| be the result of running [=clone a node=] on |node| with the
     `clone children flag` set to `true`.
  1. Let `fragment` be the result of {{createDocumentFragment}}.
  1. [=/Append=] the node |clone| to the parent |fragment|.
  1. Return |fragment|.
</div>

## Sanitization Algorithms ## {#sanitizer-algorithms}

<div algorithm="sanitize a document fragment">
To <dfn>sanitize a document fragment</dfn> named |fragment| run these steps:
  1. Let |m| be a map that maps nodes to a [=sanitize action=]
  1. Let |nodes| be a list containing the [=inclusive descendants=] of
     |fragment|, in [=tree order=].
  1. [=list/iterate|For each=] |node| in |nodes|:
    1. Let |action| be the result of running the [=sanitize a node=] algorithm
       on |node|.
    1. Insert |node| and |action| into |m|
  1. [=list/iterate|For each=] |node| in |nodes|:
    1. If m[node] is `drop`, remove the |node| and all children from |fragment|.
    1. If m[node] is `block`, replace the |node| with all of its element and text node children from |fragment|.
    1. If m[node] is `keep`, do nothing.
</div>

<div algorithm="sanitize a node">
To <dfn>sanitize a node</dfn> named |node| run these steps:
  1. Let |sanitizer| be the current Sanitizer.
  1. If |node| is an element node:
    1. Let |element| be |node|'s element.
    1. [=list/iterate|For each=] |attr| in |element|'s
       [=Element/attribute list=]:
      1. Let |attr action| be the resulf of running the
         [=effective attribute configuration=] algorithm on |sanitizer|,
         |attr|, and |element|.
      1. If |attr action| is different from `keep`, remove |attr| from
        |element|.
    1. Run the steps to [=handle funky elements=] on |element|.
    1. Let |action| be the resulf of running the
       [=effective element configuration=] algorithm on |sanitizer| and
       |element|.
    1. Return |action|.
  1. If |node| is a {{Document}} or {{DocumentFragment}} node and if |node|'s
     [=parent=] is null: Return `keep`.
  1. If |node| is a {{Comment}} [=node=]:
    1. Let |config| be |sanitizer|'s [=configuration object=], or the
       [=default configuration=] if no [=configuration object=] was given.
    1. If |config|'s [=allow comments option=] is present and is set to to `true`: Return `keep`.
    1. Return `drop`.
  1. If |node| is a {{Text}} [=node=]: Return `keep`.
  1. Return `drop`
</div>


Some HTML elements require special treatment in a way that can't be easily
expressed in terms of configuration options or other algorithms. The following
algorithm collects these in one place.

<div algorithm="handle funky elements">
To <dfn>handle funky elements</dfn> on a given |element|, run these steps:

  1. If |element|'s [=element interface=] is {{HTMLTemplateElement}}:
    1. Run the steps of the [=sanitize a document fragment=] algorithm on
       |element|'s |content| attribute, and replace |element|'s |content|
       attribute with the result.
    1. Drop all child nodes of |element|.
  1. If |element|'s [=element interface=] has a {{HTMLHyperlinkElementUtils}}
     mixin, and if |element|'s `protocol` property is "javascript:":
    1. Remove the `href` attribute from |element|.
  1. if |element|'s [=element interface=] is {{HTMLFormElement}},
     and if |element|'s `action` attribute is a [[URL]] with `javascript:`
     protocol:
    1. Remove the `action` attribute from |element|.
  1. if |element|'s [=element interface=] is {{HTMLInputElement}}
      or {{HTMLButtonElement}}, and if |element|'s `formaction` attribute is
      a [[URL]] with `javascript:` protocol
    1. Remove the `formaction` attribute from |element|.
</div>

### The Effective Configuration ### {#configuration}

A Sanitizer is potentially complex, so we will define a helper
construct, the *effective configuration*. This is mostly a specification
convenience and allows us to explain a Sanitizer's operation in two steps:
One, how to derive the effective configuration, and two, define the
Sanitzer's operation based on it.

An effective configuration maps a given |element| or a given pair of
|element| and |attribute| to a [=sanitize action=].

A <dfn>sanitize action</dfn> can have the values `keep`, `drop`, or `block`.
To determine the <dfn>stricter action</dfn> of two [=sanitize actions=], pick
the 'larger' of the two actions assuming a transitively defined order with
`drop` &gt; `block`, and `block` &gt; `keep`.

<div algorithm="effective element configuration">
To determine a Sanitizer |sanitizer|'s
<dfn>effective element configuration</dfn> for an element |element|,
run these steps:
  1. Let |config| be |sanitizer|'s [=configuration object=].
  1. Let |baseline action| be the result of running the steps of the
     [=determine the baseline configuration for an element=] algorithm
     for the element |element|.
  1. Let |config action| be the result of running the steps of the
     [=determine the effective configuration for an element=] algorithm
     for the element |element| and the config |config|.
  1. Return the [=stricter action=] of |baseline action| and |config action|.

Note: The definition of stricter actions ensures that the built-in baseline
      configuration cannot be overriden, and therefor forms a hard guarantee
      for all Sanitizer instances. (Likewise for attributes.)
</div>

<div algorithm="effective attribute configuration">
To determine a Sanitizer |sanitizer|'s
<dfn>effective attribute configuration</dfn> for an attribute |attr|
attached to an element |element|, run these steps:
  1. Let |config| be |sanitizer|'s [=configuration object=].
  1. Let |baseline action| be the result of running the steps of the
     [=determine the baseline configuration for an attribute=] algorithm
     on the attribute |attr|.
  1. Let |config action| be the result of running the steps of the
     [=determine the effective configuration for an attribute=] algorithm
     on the attribute |attr|, with the element |element| and the
     config |config|.
  1. Return the [=stricter action=] of |baseline action| and |config action|.
</div>

Before describing how an effective configuration is derived, we need a
helper definition:

<div algorithm="element kind">
The <dfn>element kind</dfn> of an |element| is one of `regular`, `unknown`,
or `custom`. Let <var ignore>element kind</var> be:
  - `custom`, if |element|'s [=Element/local name=] is a [=valid custom element name=],
  - `unknown`, if |element| is not in the [[HTML]] namespace or if |element|'s
     [=Element/local name=] denotes an unknown element &mdash; that is, if the
     [=element interface=] the [[HTML]] specification assigns to it would
     be {{HTMLUnknownElement}},
  - `regular`, otherwise.
</div>

<div algorithm="attribute kind">
Similarly, the <dfn>attribute kind</dfn> of an |attribute| is one of `regular`
or `unknown`. Let <var ignore>attribute kind</var> be:
  - `unknown`, if the [[HTML]] specification does not assign any meaning to
     |attribute|'s name.
  - `regular`, otherwise.
</div>

Issue(WICG/sanitizer-api#72): The spec currently treats MathML and SVG as
    `unknown` content and therefore blocked by default. This needs to be fixed.

<div algorithm="determine the effective configuration for an element">
To <dfn>determine the effective configuration for an element</dfn> |element|,
given a [=configuration object=] |config|, run these steps:

  1. If |element|'s [=element kind=] is `custom` and if |config|'s
     [=allow custom elements option=] is unset or set to anything other
     than `true`: Return `drop`.
  1. Let |name| be the |element|'s [=Element/local name=].
  1. If |name| is in |config|'s [=element drop list=]: Return `drop`.
  1. If |name| is in |config|'s [=element block list=]: Return `block`.
  1. If |config| has a non-empty [=element allow list=] and |name| is not
     in |config|'s [=element allow list=]: Return `block`.
  1. If |config| does not have a non-empty [=element allow list=] and
     |name| is not it the [=default configuration=]'s [=element allow list=]:
     Return `block`.
  1. Return `keep`.
</div>

<div algorithm="determine the effective configuration for an attribute">
To <dfn>determine the effective configuration for an attribute</dfn> |attr|,
attached to an element |element|, and given a [=configuration object=] |config|,
run these steps:

  1. if |config|'s [=attribute drop list=] contains |attr|'s [=Attr/local name=]
     as key, and the associated value contains either |element|'s
     ]=Element/local name=] or the string `"*"`: Return `drop`.
  1. If |config| has a non-empty [=attribute allow list=] and it does not
     contain |attr|'s [=Attr/local name=], or
     |attr|'s associated value contains neither
     |element|'s [=Element/local name=] nor the string `"*"`: Return `drop`.
  1. if |config| does not have a non-empty [=attribute allow list=] and
     [=default configuration=]'s [=attribute allow list=] does not contain
     |attr|'s [=Attr/local name=], or |attr|'s associated value contains
     neither |element|'s [=Element/local name=] nor the string `"*"`:
     Return `drop`.
  1. Return `keep`.

Note: The element names in the Sanitizer configuration are normalized according
  to normalization step in the HTML Parser, just like elements'
  [=Element/local names=] are. Thus, the comparison is effectively case
  insensitive.
</div>

## Baseline and Defaults ## {#defaults}

Issue: The sanitizer baseline and defaults need to be carefully vetted, and
    are still under discussion. The values below are for illustrative
    purposes only.

<div algorithm="determine the baseline configuration for an element">
To <dfn>determine the baseline configuration for an element</dfn>
|element|, run these steps:
  1. if |element|'s [=element kind=] is `regular` and if |element|'s
     [=Element/local name=] is not in the [=baseline element allow list=]:
     Return `drop`.
  1. Return `keep`.
</div>

<div algorithm="determine the baseline configuration for an attribute">
To <dfn>determine the baseline configuration for an attribute</dfn>
|attr|, run these steps:
  1. If |attr|'s [=attribute kind=] is `regular` and if |attr|'s
     name is not in the [=baseline attribute allow list=]: Return `drop`
  1. Return `keep`.
</div>

The sanitizer has a built-in [=default configuration=], which is stricter than
the baseline and aims to eliminate any script-injection possibility, as well
as legacy or unusual constructs.

The defaults and baseline are defined by three JSON constants,
[=baseline element allow list=], [=baseline attribute allow list=],
[=default configuration=]. For better readability, these have been moved to
an <a href=#constants>appendix A</a>.


# Security Considerations # {#security-considerations}

The Sanitizer API is intended to prevent DOM-Based Cross-Site Scripting
by traversing a supplied HTML content and removing elements and attributes
according to a configuration. The specified API must not support
the construction of a Sanitizer object that leaves script-capable markup in
and doing so would be a bug in the threat model.

That being said, there are security issues which the correct usage of the
Sanitizer API will not be able to protect against and the scenarios will be
laid out in the following sections.

## Server-Side Reflected and Stored XSS ## {#server-side-xss}

<em>This section is not normative.</em>

The Sanitizer API operates solely in the DOM and adds a capability to traverse
and filter an existing DocumentFragment. The Sanitizer does not address
server-side reflected or stored XSS.

## DOM clobbering ## {#dom-clobbering}

<em>This section is not normative.</em>

DOM clobbering describes an attack in which malicious HTML confuses an
application by naming elements through `id` or `name` attributes such that
properties like `children` of an HTML element in the DOM are overshadowed by
the malicious content.

The Sanitizer API does not protect DOM clobbering attacks in its
default state, but can be configured to remove `id` and `name` attributes.

## XSS with Script gadgets ## {#script-gadgets}

<em>This section is not normative.</em>

Script gadgets is a technique in which an attacker uses existing application
code from popular JavaScript libraries to cause their own code to execute.
This is often done by injecting innocent-looking code or seemingly inert
DOM nodes that is only parsed and interpreted by a framework which then
performs the execution of JavaScript based on that input.

The Sanitizer API can not prevent these attacks, but requires page authors to
explicitly allow attributes and elements that are unknown to HTML and markup
that is known to be widely used for templating and framework-specific code,
like `data-` and `slot` attributes and elements like `<slot>` and `<template>`.
We believe that these restrictions are not exhaustive and encourage page
authors to examine their third party libraries for this behavior.

## Mutated XSS ## {#mutated-xss}

<em>This section is not normative.</em>

Mutated XSS or mXSS describes an attack based on parser context mismatches
when parsing an HTML snippet without the correct context. In particular,
when a parsed HTML fragment has been serialized to a string, the string is
not guaranteed to be parsed and interpreted exactly the same when inserted
into a different parent element. An example for carrying out such an attack
is by relying on the change of parsing behavior for foreign content or
misnested tags.

The Sanitizer API offers help against Mutated XSS, but relies on some amount of
cooperation by the developers. The `sanitize()` function does not handle strings
and is therefore unaffected. The `setHTML` function combines sanitization
with DOM modification and can implicitly apply the correct context. The
`sanitizeFor()` function combines parsing and sanitization, and relies on the
developer to supply the correct context for the eventual application of its
result.

If the data to be sanitized is available as a node tree, we encourage authors
to use the `sanitize()` function of the API which returns a
DocumentFragment and avoids risks that come with serialization and additional
parsing. Directly operating on a fragment after sanitization also comes with a
performance benefit, as the cost of additional serialization and parsing is
avoided.

A more complete treatement of mXSS can be found in [[MXSS]].

# Acknowledgements # {#ack}

Cure53's [[DOMPURIFY]] is a clear inspiration for the API this document
describes, as is Internet Explorer's {{window.toStaticHTML()}}.

# Appendix A: Built-in Constants # {#constants}

<em>This appendix is normative, except where explicitly noted otherwise.</em>

These constants define core behaviour of the Sanitizer algorithm.

## Built-ins Justification ## {#builtins-justification}

<em>This subsection is super duper non-normative.</em>

Note: The normative values of these constants are found below. The derivation
    of these are explained here, with an implementation in the [[DEFAULTS]]
    script. It is expected that these values will change before this
    specification is finalized. Also, we expect these
    to be updated to include additional HTML elements as they are
    introduced in user agents.

For the purpose of this Sanitizer API, [[HTML]] constructs fall into one of
four classes, where the first defines the baseline, and the first, second,
plus the third define the default:

1. Elements and attributes that (directly) execute script.
   In other words, elements and attributes that are unconditionally script-ish.
1. Legacy and "difficult" elements and attributes.
  Examples are the `<plaintext>` `<xmp>` and elements, which have special
  parsing rules attached to them. These are not dangerous _per se_, but they
  have contributed to existing vulnerability.
1. Elements and attributes that we feel rarely make sense in user-supplied
  content.
1. All the rest.

Specifically:

1. Script-ish constructs:
  - The {{HTMLScriptElement}}, which proudly executes script as its sole purpose.
  - All [event handler attributes]((https://html.spec.whatwg.org/#event-handler-attributes),
    since these also execute script.
  - {{HTMLIFrameElement}}, which loads arbitrary HTML content and therefor also script.
  - The legacy {{HTMLObjectElement}} and {{HTMLEmbedElement}}, which load
    non-HTML active content. Also, `<object>`'s side-kick {{HTMLParamElement}}.
  - The [no-longer conforming](https://html.spec.whatwg.org/#non-conforming-features)
    `<frame>`, `<frameset>`, and `<applet>` tags, which are
    outdated versions companions of several elements listed above.
  - The `<noscript>`, `<noframes>`, `<noembed>`, and `<nolayer>` elements.
    These, by themselves, are arguably not script-ish, but they are companions
    to elements listed above, and make no sense on their own.
  - Also, the {{HTMLBaseElement}}, as this effectively modifies interpretation
    of other URLs.

1. Legacy and "difficult" elements.
  - Special parsing behaviour. This is not dangerous in its own right, but has
    contributed to mXSS-style attacks. This includes:
      - `<plaintext>` (Which parses in [=PLAINTEXT state=].)
      - `<title>` and `<textarea>` (Which parse in [=RCDATA state=].)
      - The non-conforming [`<xmp>`](https://html.spec.whatwg.org/#xmp) element.
  - Legacy elements:
      - `<image>` ([which is parsed as `<img>`](https://html.spec.whatwg.org/#parsing-main-inbody)).
      - `<basefont>`

1. Constructs unlikely to be beneficial in user-supplied content:
  - The {{HTMLTemplateElement}}, which introduces a new template to be used
    by JavaScript, and its {{HTMLSlotElement}} accomplice.
  - The frame-like [HTMLPortalElement](https://wicg.github.io/portals/).
  - {{HTMLDataElement}},
  - The (deprecated) [allowpaymentrequest](https://www.w3.org/TR/payment-request/) attribute.

## The Baseline Element Allow List ## {#baseline-elements}

The built-in <dfn>baseline element allow list</dfn> has the following value:

<pre class=include-code>
path: resources/baseline-element-allow-list.json
highlight: js
</pre>

## The Baseline Attribute Allow List ## {#baseline-attributes}

The <dfn>baseline attribute allow list</dfn> has the following value:

<pre class=include-code>
path: resources/baseline-attribute-allow-list.json
highlight: js
</pre>

## The Default Configuration Object ## {#default-configuration-object}

The built-in <dfn>default configuration</dfn> has the following value:

<pre class=include-code>
path: resources/default-configuration.json
highlight: js
</pre>
