<pre class="metadata">
Title: HTML Sanitizer API
Status: CG-DRAFT
Group: WICG
URL: https://wicg.github.io/sanitizer-api/
Repository: WICG/sanitizer-api
Shortname: sanitizer-api
Level: 1
Editor: Frederik Braun 68466, Mozilla, fbraun@mozilla.com, https://frederik-braun.com
Editor: Mario Heiderich, Cure53, mario@cure53.de, https://cure53.de
Editor: Daniel Vogelheim, Google LLC, vogelheim@google.com, https://www.google.com
Abstract:
  This document specifies a set of APIs which allow developers to take
  untrusted HTML input and sanitize it for safe insertion into a document's
  DOM.
Indent: 2
Work Status: exploring
Boilerplate: omit conformance
Markup Shorthands: css off, markdown on
WPT Display: inline
WPT Path Prefix: /sanitizer-api/
</pre>
<pre class="anchors">
text: innerHTML; type: attribute; for: Element; url: https://dom.spec.whatwg.org/#widl-Element-innerHTML
text: window.toStaticHTML(); type: method; url: https://msdn.microsoft.com/en-us/library/cc848922(v=vs.85).aspx
text: createDocumentFragment; type: method; url: https://dom.spec.whatwg.org/#dom-document-createdocumentfragment
text: template contents; type: dfn; url: https://html.spec.whatwg.org/#template-contents
</pre>
<pre class="biblio">
{
  "DOMPURIFY": {
    "href": "https://github.com/cure53/DOMPurify",
    "title": "DOMPurify",
    "publisher": "Cure53"
  },
  "MXSS": {
    "href": "https://cure53.de/fp170.pdf",
    "title": "mXSS Attacks: Attacking well-secured Web-Applications by using innerHTML Mutations",
    "publisher": "Ruhr-Universit√§t Bochum"
  }
}
</pre>

# Introduction # {#intro}

<em>This section is not normative.</em>

Web applications often need to work with strings of HTML on the client side,
perhaps as part of a client-side templating solution, perhaps as part of
rendering user generated content, etc. It is difficult to do so in a safe way.
The naive approach of joining strings together and stuffing them into
an {{Element}}'s {{Element/innerHTML}} is fraught with risk, as it can cause
JavaScript execution in a number of unexpected ways.

Libraries like [[DOMPURIFY]] attempt to manage this problem by carefully
parsing and sanitizing strings before insertion, by constructing a DOM and
filtering its members through an allow-list. This has proven to be a fragile
approach, as the parsing APIs exposed to the web don't always map in
reasonable ways to the browser's behavior when actually rendering a string as
HTML in the "real" DOM. Moreover, the libraries need to keep on top of
browsers' changing behavior over time; things that once were safe may turn
into time-bombs based on new platform-level features.

The browser has a fairly good idea of when it is going to
execute code. We can improve upon the user-space libraries by teaching the
browser how to render HTML from an arbitrary string in a safe manner, and do
so in a way that is much more likely to be maintained and updated along with
the browser's own changing parser implementation. This document outlines an
API which aims to do just that.

## Goals ## {#goals}

*   Mitigate the risk of DOM-based cross-site scripting attacks by providing
    developers with mechanisms for handling user-controlled HTML which prevent
    direct script execution upon injection.

*   Make HTML output safe for use within the current user agent, taking into
    account its current understanding of HTML.

*   Allow developers to override the defaults set of elements and attributes.
    Adding certain elements and attributes can prevent
    <a href="https://github.com/google/security-research-pocs/tree/master/script-gadgets">script gadget</a>
    attacks.

## API Summary ## {#api-summary}

The Sanitizer API offers functionality to parse a string containing HTML into
a DOM tree, and to filter the resulting tree according to a user-supplied
configuration. The methods come in two by two flavours:

* Safe and unsafe: The "safe" methods will not generate any markup that executes
  script. That is, they should be safe from XSS. The "unsafe" methods will parse
  and filter whatever they're supposed to.
* Context: Methods are defined on {{Element}} and {{ShadowRoot}} and will
  replace these {{Node}}'s children, and are largely analogous to {{innerHTML}}.
  There are also static methods on the {{Document}}, which parse an entire
  document are are largely analogous to {{DOMParser}}.{{parseFromString()}}.


# Framework # {#framework}

## Sanitizer API ## {#sanitizer-api}

The {{Element}} interface defines two methods, {{Element/setHTML()}} and
{{Element/setHTMLUnsafe()}}. Both of these take a {{DOMString}} with HTML
markup, and an optional configuration.

<pre class=idl>
partial interface Element {
  [CEReactions] undefined setHTMLUnsafe(DOMString html, optional SanitizerConfig config);
  [CEReactions] undefined setHTML(DOMString html, optional SanitizerConfig config);
};
</pre>

<div algorithm="DOM-Element-setHTMLUnsafe" export>
{{Element}}'s <dfn for="DOM/Element">setHTMLUnsafe</dfn>(|html|, |options|?) method steps are:

1. Let |target| be |this|'s [=template contents=] if [=this=] is {{HTMLTemplateElement|template}} element; otherwise |this|.
1. [=Unsafely set HTML=] given |target|, [=this=], |html|, and |options|.

</div>

<div algorithm="DOM-Element-setHTML" export>
{{Element}}'s <dfn for="DOM/Element">setHTML</dfn>(|html|, |options|?) method steps are:

1. Let |target| be |this|'s [=template contents=] if [=this=] is a
   {{HTMLTemplateElement|template}}; otherwise |this|.
1. [=Safely set HTML=] given |target|, [=this=], |html|, and |options|.

</div>

<pre class=idl>
partial interface ShadowRoot {
  [CEReactions] undefined setHTMLUnsafe(DOMString html, optional SanitizerConfig config);
  [CEReactions] undefined setHTML(DOMString html, optional SanitizerConfig config);
};
</pre>

These methods are mirrored on the {{ShadowRoot}}:

<div algorithm="ShadowRoot-setHTMLUnsafe" export>
{{ShadowRoot}}'s <dfn for="DOM/ShadowRoot">setHTMLUnsafe</dfn>(|html|, |options|?) method steps are:

1. [=Unsafely set HTML=] using [=this=], |html|, and |options|.

</div>

<div algorithm="ShadowRoot-setHTML" export>
{{ShadowRoot}}'s <dfn for="DOM/ShadowRoot">setHTML</dfn>(|html|, |options|?)</dfn> method steps are:

1. [=Safely set HTML=] using [=this=], |html|, and |options|.

</div>

The {{Document}} interface gains two new methods which parse an entire {{Document}}:

<pre class=idl>
partial interface Document {
  static Document parseHTMLUnsafe(DOMString html, optional SanitizerConfig config);
  static Document parseHTML(DOMString html, optional SanitizerConfig config);
};
</pre>

<div algorithm="parseHTMLUnsafe" export>
The <dfn for="DOM/Document">parseHTMLUnsafe</dfn>(|html|, |options|?) method steps are:

1. Let |document| be a new {{Document}}, whose [=Document/content type=] is "text/html".
   Note: Since document does not have a browsing context, scripting is disabled.
1. Set |document|'s [=allow declarative shadow roots=] to `true`.
1. [=Parse HTML=] from a string given |document| and |html|.
1. If |options| is set:
1. Let |config| be the result of calling [=canonicalize a configuration=] on
   |options|[`"sanitizer"`] and `false`.
   1. Call [=sanitize=] on |document|'s [=tree/root|root node=] with |config|.
1. Return |document|.

</div>


<div algorithm="parseHTML" export>
The <dfn for="DOM/Document">parseHTML</dfn>(|html|, |options|?) method steps are:

1. Let |document| be a new {{Document}}, whose [=Document/content type=] is "text/html".
   Note: Since document does not have a browsing context, scripting is disabled.
1. Set |document|'s [=allow declarative shadow roots=] to `true`.
1. [=Parse HTML=] from a string given |document| and |html|.
1. Let |config| be the result of calling [=canonicalize a configuration=] on
   |options|[`"sanitizer"`] and `true`.
1. Call [=sanitize=] on |document|'s [=tree/root|root node=] with |config|.
1. Return |document|.

NOTE: An actual implementation would presumably merge the two [=sanitize=] calls.
</div>



## The Configuration Dictionary ## {#config}

<pre class=idl>
dictionary SanitizerElementNamespace {
  required DOMString name;
  DOMString? _namespace = "http://www.w3.org/1999/xhtml";
};

// Used by "elements"
dictionary SanitizerElementNamespaceWithAttributes : SanitizerElementNamespace {
  sequence&lt;SanitizerAttribute> attributes;
  sequence&lt;SanitizerAttribute> removeAttributes;
};

typedef (DOMString or SanitizerElementNamespace) SanitizerElement;
typedef (DOMString or SanitizerElementNamespaceWithAttributes) SanitizerElementWithAttributes;

dictionary SanitizerAttributeNamespace {
  required DOMString name;
  DOMString? _namespace = null;
};
typedef (DOMString or SanitizerAttributeNamespace) SanitizerAttribute;

dictionary SanitizerConfig {
  sequence&lt;SanitizerElementWithAttributes> elements;
  sequence&lt;SanitizerElement> removeElements;
  sequence&lt;SanitizerElement> replaceWithChildrenElements;

  sequence&lt;SanitizerAttribute> attributes;
  sequence&lt;SanitizerAttribute> removeAttributes;

  boolean comments;
};
</pre>

## Canonical Configuration ## {#config-canonical}

For the purpose of specifying these algorithms, we define a <dfn>canonical
configuration</dfn>. These [=canonical configurations=] are meant to be a subset
of allowed configurations, that eliminate redundant ways to express the same thing.

For example, the regular configuration allows element or attributes to be described
by string containing its name (in a default namespace); by a dictionary with a
name string and an implied namespace,
or by a dictionary with both name and namespace given explicitly. The canonical
configuration allows only the latter form, a dictionary with explicit name and
namespaces.

The [=canonical configuration=] is chiefly a specification tool that users
do not need to concern themselves with. But it allows us to specify the
Sanitizer operation in two steps: First canonicalize the configuration, and then
have a (simpler) algorithm that will do the actual sanitization.

<pre class=idl>
dictionary CanonicalSanitizerName {
  required DOMString name;
  required DOMString _namespace;
};
dictionary CanonicalSanitizerNameWithAttributes : CanonicalSanitizerName {
  sequence&lt;CanonicalSanitizerName> attributes;
  sequence&lt;CanonicalSanitizerName> removeAttributes;
};
dictionary CanonicalSanitizerConfig {
  sequence&lt;CanonicalSanitizerNameWithAttributes> elements;
  sequence&lt;CanonicalSanitizerName> removeElements;
  sequence&lt;CanonicalSanitizerName> replaceWithChildrenElements;
  sequence&lt;CanonicalSanitizerName> attributes;
  sequence&lt;CanonicalSanitizerName> removeAttributes;
  required boolean comments;
};
</pre>

# Algorithms # {#algorithms}

<div algorithm>
To <dfn>unsafely set HTML</dfn>, given an {{Element}} or {{DocumentFragment}} |target|, an {{Element}} |contextElement|, a [=string=] |html|, and a [=dictionary=] |options|:

1. Let |config| be the result of calling [=canonicalize a configuration=] on
   |options|[`"sanitizer"`] and `false`.
1. Run [=set and filter HTML=] on |target|, |contextElement|, |html|, and |config|.

</div>

<div algorithm>
To <dfn>safely set HTML</dfn>, given an {{Element}} or {{DocumentFragment}} |target|, an {{Element}} |contextElement|, a [=string=] |html|, and a [=dictionary=] |options|:

1. Let |config| be the result of calling [=canonicalize a configuration=] on
   |options|[`"sanitizer"`] and `true`.
1. Run [=set and filter HTML=] on |target|, |contextElement|, |html|, and |config|.

</div>

<div algorithm>
To <dfn>set and filter HTML</dfn>, given an {{Element}} or {{DocumentFragment}} |target|, an {{Element}} |contextElement|, a [=string=] |html|, and a [=canonical=] |config|, run these steps:

1. Let |newChildren| be the result of the HTML [=fragment parsing algorithm=]
   given |contextElement|, |html|, and `true`.
1. Let |fragment| be a new {{DocumentFragment}} whose [=node document=] is |contextElement|'s [=node document=].
1. [=list/iterate|For each=] |node| in |newChildren|, [=list/append=] |node| to |fragment|.
1. Run [=sanitize=] on |fragment| using |config|.
1. [=Replace all=] with |fragment| within |target|.

</div>

## Sanitization Algorithms ## {#sanitization}

<div algorithm="sanitize">
For the main <dfn>sanitize</dfn> operation, using a {{ParentNode}} |node|, a
[=canonical=] {{SanitizerConfig}} |config|, run these steps:

1. [=Assert=]: |config| is [=canonical=].
1. Initialize |current| with |node|.
1. [=list/iterate|For each=] |child| in |current|'s [=tree/children=]:
  1. [=Assert=]: |child| [=implements=] {{Text}}, {{Comment}}, or {{Element}}.

     Note: Currently, this algorithm is only be called on output of the HTML
           parser, for which this assertion should hold. If this is to be
           generalized, this algorithm needs to be re-examined.
  1. If |child| [=implements=] {{Text}}:
    1. Do nothing.
  1. else if |child| [=implements=] {{Comment}}:
    1. If |config|'s {{CanonicalSanitizerConfig/comments}} is not `true`:
      1. {{Node/removeChild()}} |child| from |current|.
  1. else if |child| [=implements=] {{Element}}:
    1. Let |element-name| be a {{CanonicalSanitizerName}} with |child|'s
       [=Element/local name=] and [=Element/namespace=].
    1. If |config|[{{CanonicalSanitizerConfig/elements}}] exists and
       |config|[{{CanonicalSanitizerConfig/elements}}] does not [=list/contain=]
       [|element-name|]:
       1. Call {{Node/removeChild()}} on |child|.
    1. else if |config|[{{CanonicalSanitizerConfig/removeElements}}] exists and
       |config|[{{CanonicalSanitizerConfig/removeElements}}] [=list/contains=]
       [|element-name|]:
       1. Call {{Node/removeChild()}} on |child|.
    1. If |config|[{{CanonicalSanitizerConfig/replaceWithChildrenElements}}] exists and |config|[{{CanonicalSanitizerConfig/replaceWithChildrenElements}}] [=list/contains=] |element-name|:
      1. Call [=sanitize=] on |child| with |config|.
      1. Call {{ParentNode/replaceChildren()}} on |child| with |child|'s
         [=tree/children=] as arguments.
    1. [=list/iterate|For each=] |attr| in |current|'s [=Element/attribute list=]:
      1. Let |attr-name| be a {{CanonicalSanitizerName}} with |attr|'s
         [=Attr/local name=] and [=Attr/namespace=].
      1. If |config|[{{CanonicalSanitizerConfig/attributes}}] exists and
         |config|[{{CanonicalSanitizerConfig/attributes}}] does not [=list/contain=]
         [attr-name|:
         1. Remove |attr| from |child|.
      1. else if |config|[{{CanonicalSanitizerConfig/removeAttributes}}] exists and
         |config|[{{CanonicalSanitizerConfig/removeAttributes}}] [=list/contains=]
         [attr-name|:
         1. Remove |attr| from |child|.
      1. If |config|[{{CanonicalSanitizerConfig/elements}}][|element-name|] exists,
         and if
         |config|[{{CanonicalSanitizerConfig/elements}}][|element-name|][{{CanonicalSanitizerNameWithAttributes/attributes}}]
         exists, and if
         |config|[{{CanonicalSanitizerConfig/elements}}][|element-name|][{{CanonicalSanitizerNameWithAttributes/attributes}}]
         does not [=list/contain=] |attr-name|:
         1. Remove |attr| from |child|.
      1. If |config|[{{CanonicalSanitizerConfig/elements}}][|element-name|] exists,
         and if
         |config|[{{CanonicalSanitizerConfig/elements}}][|element-name|][{{CanonicalSanitizerNameWithAttributes/removeAttributes}}]
         exists, and if
         |config|[{{CanonicalSanitizerConfig/elements}}][|element-name|][{{CanonicalSanitizerNameWithAttributes/removeAttributes}}]
         [=list/contains=] |attr-name|:
    1. If |child| is a [=Element/shadow host=]:
       1. Call [=sanitize=] on |child|'s [=Element/shadow root=] with |config|.
    1. else:
      1. Call {{Node/removeChild()}} on |child|.
  1. else:
    1. [=Assert=]: We shouldn't reach this branch.

TODO: Add "funky elements" / handling of `javascript:`-URLs back in.

</div>

## Configuration Processing ## {#configuration-processing}

<div algorithm>
A |config| is <dfn>valid</dfn> if all these conditions are met:

1. |config| [=conforms=] to {{SanitizerConfig}}.
1. |config| [=map/keys=] contains either {{SanitizerConfig/elements}} or
   {{SanitizerConfig/removeElements}}, or neither of them, but not both.
1. |config| [=map/keys=] contains either {{SanitizerConfig/removeAttributes}}
   or {{SanitizerConfig/attributes}}, or neither, but not both.
1. If |config|[{{SanitizerConfig/elements}}] exists, then none of its members'
   [=map/keys=] contains both {{SanitizerElementNamespaceWithAttributes/attributes}}
   and {{SanitizerElementNamespaceWithAttributes/removeAttributes}}.
1. TODO: check that name dictionaries must contain "name"

</div>

<div algorithm>
A |config| is <dfn>canonical</dfn> if all these conditions are met:

1. |config| is [=valid=].
1. |config| [=strictly conforms=] to {{CanonicalSanitizerConfig}}.
1. |config|'s [=map/keys|key set=] [=set/equals=] any of:
   1. &laquo;
      {{SanitizerConfig/elements}},
      {{SanitizerConfig/attributes}},
      {{SanitizerConfig/comments}}
      &raquo;
   1. &laquo;
      {{SanitizerConfig/elements}},
      {{SanitizerConfig/replaceWithChildrenElements}},
      {{SanitizerConfig/attributes}},
      {{SanitizerConfig/comments}}
      &raquo;
   1. &laquo;
      {{SanitizerConfig/removeElements}},
      {{SanitizerConfig/removeAttributes}},
      {{SanitizerConfig/comments}}
      &raquo;
   1. &laquo;
      {{SanitizerConfig/removeElements}},
      {{SanitizerConfig/removeAttributes}},
      {{SanitizerConfig/replaceWithChildrenElements}},
      {{SanitizerConfig/comments}}
      &raquo;
1. TODO: Elements with attributes

</div>

<div algorithm>
In order to <dfn>canonicalize a configuration</dfn> |config| with a boolean
parameter |safe|, run the following steps:

TODO: Handle empty |config|.

1. If |config| is not [=valid=], then [=throw=] a {{TypeError}}.
1. Let |result| be a new [=dictionary=].
1. For each |key| of
   {{SanitizerConfig/elements}},
   {{SanitizerConfig/removeElements}},
   {{SanitizerConfig/replaceWithChildrenElements}}:
  1. If |config|[|key|] exists, set |result|[|key|] to the result of running
     [=canonicalize a sanitizer element list=] on |config|[|key|] with
     [=HTML namespace=] as the default namespace.
1. For each |key| of
   {{SanitizerConfig/attributes}},
   {{SanitizerConfig/removeAttributes}}:
  1. If |config|[|key|] exists, set |result|[|key|] to the result of running
     [=canonicalize a sanitizer element list=] on |config|[|key|] with `""` as
     the default namespace.
1. Set |result|[{{SanitizerConfig/comments}}] to
   |config|[{{SanitizerConfig/comments}}].
1. Let |default| be the result of [=canonicalizing a configuration=] for the
   [=built-in default config=].
1. If |safe|:
   1. Let |known elements| be an [=ordered set=] of all elements known to the
      [[HTML]] specification, where the set members [=strictly conform=] to
      {{CanonicalSanitizerName}}.
   1. Let |known attributes| be an [=ordered set=] of all attributes known to the
      [[HTML]] specification, where the set members [=strictly conform=] to
      {{CanonicalSanitizerName}}.
   1. If |config|[{{SanitizerConfig/elements}}] [=map/exists=]:
      1. Set |result|[{{SanitizerConfig/elements}}] to the
         [=intersection complement=] of |result|[{{SanitizerConfig/elements}}] and
         the [=intersection complement=] of |known elements| and
         |default|[{{SanitizerConfig/elements}}].

         Note: This sounds more complicated than it is. This the same as the
               [=set/intersection=] of |result|[{{SanitizerConfig/elements}}] and
               |default|[{{SanitizerConfig/elements}}], except that it also
               preserves unknown HTML elements, which a plain [=set/intersection=]
               would remove.
   1. If |config|[{{SanitizerConfig/removeElements}}] [=map/exists=]:
       1. Set |result|[{{SanitizerConfig/elements}}] to the
          [=intersection complement=] of |default|[{{SanitizerConfig/elements}}]
          and |result|[{{SanitizerConfig/removeElements}}].
       1. [=set/Remove=] {{SanitizerConfig/removeElements}} from |result|.
   1. If neither |config|[{{SanitizerConfig/elements}}] nor
      |config|[{{SanitizerConfig/removeElements}}] [=map/exist=]:
      1. Set |result|[{{SanitizerConfig/elements}}] to
         |default|[{{SanitizerConfig/elements}}].
   1. If |config|[{{SanitizerConfig/attributes}}] [=map/exists=]:
      1. Set |result|[{{SanitizerConfig/attributes}}] to the
         [=intersection complement=] of |result|[{{SanitizerConfig/attributes}}] and
         the [=intersection complement=] attributes |known attributes| and
         |default|[{{SanitizerConfig/attributes}}].
   1. If |config|[{{SanitizerConfig/removeAttributes}}] [=map/exists=]:
       1. Set |result|[{{SanitizerConfig/attributes}}] to the
          [=intersection complement=] of |default|[{{SanitizerConfig/attributes}}]
          and |result|[{{SanitizerConfig/removeAttributes}}].
       1. [=set/Remove=] {{SanitizerConfig/removeAttributes}} from |result|.
   1. If neither |config|[{{SanitizerConfig/attributes}}] nor
      |config|[{{SanitizerConfig/removeAttributes}}] [=map/exist=]:
      1. Set |result|[{{SanitizerConfig/attributes}}] to
         |default|[{{SanitizerConfig/attributes}}].
1. Else (if not |safe|):
   1. If neither  |config|[{{SanitizerConfig/elements}}] nor
      |config|[{{SanitizerConfig/removeElements}} [=map/exist=]:
      1. Set |result|[{{SanitizerConfig/elements}}] to
         |default|[{{SanitizerConfig/elements}}].
   1. If neither  |config|[{{SanitizerConfig/attributes}}] nor
      |config|[{{SanitizerConfig/removeAttributes}} [=map/exist=]:
      1. Set |result|[{{SanitizerConfig/attributes}}] to
         |default|[{{SanitizerConfig/attributes}}].
1. [=Assert=]: |result| is [=valid=].
1. [=Assert=]: |result| is [=canonical=].
1. Return |result|.

</div>

<div algorithm>
In order to <dfn>canonicalize a sanitizer element list</dfn> |list|, with a
default namespace |default namespace|, run the following steps:

1. Let |result| be a new [=ordered set=].
2. [=list/iterate|For each=] |name| in |list|, call
   [=canonicalize a sanitizer name=] on |name| with |default namespace| and
   [=set/append=] to |result|.
3. Return |result|.

</div>

<div algorithm>
In order to <dfn>canonicalize a sanitizer name</dfn> |name|, with a default
namespace |default namespace|, run the following steps:

1. [=Assert=]: |name| is either a {{DOMString}} or a [=dictionary=].
1. If |name| is a {{DOMString}}:
  1. Return &laquo;[ `"name"` &rightarrow; |name|, `"namespace"` &rightarrow; |default namespace|]&raquo;.
1. [=Assert=]: |name| is a [=dictionary=] and |name|["name"] [=map/exists=].
1. Return &laquo;[ <br>
  `"name"` &rightarrow; |name|["name"], <br>
  `"namespace"` &rightarrow; |name|["namespace"] if it [=map/exists=], otherwise |default namespace| <br>
  ]&raquo;.

</div>

## Supporting Algorithms ## {#alg-support}

<div algorithm>
The <dfn>intersection complement</dfn> of two [=ordered sets=] |A| and |B|, is
the result of creating a new [=ordered set=] |set| and, [=list/iterate|for each=]
|item| of |A|, if |B| does not [=set/contain=] item, [=set/appending=] |item| to
|set|.

Note: [=intersection complement=] is the same as [=set/intersection=], but with the
      complement of parameter |B|.
</div>

<div algorithm>
[=Ordered sets=] |A| and |B| are <dfn for=set>equal</dfn> if both |A| is a [=superset=] of
|B| and |B| is a [=superset=] of |A|.

Note: Equality for [=ordered sets=] is equality of its members, but without
regard to order.
</div>

<div algorithm>
A value |D| <dfn>conforms</dfn> to a
[=dictionary|dictionary definition=] if |D| is a [=map=] and all of |D|'s [=map/entries=]
corrspond to [=dictionary members=], as long as those entries have the correct
types, and there are [=map/entries=] present for any [=dictionary member/required=] or
[=dictionary member/default value|defaulted=] dictionary members, and any [=dictionary=]-typed values [=conform=] to their [=dictionary member=]'s type.

Note: This largely corresponds to language in [=dictionary=], but re-words this
as a predicate.
</div>

<div algorithm>
A value |D| <dfn>strictly conforms</dfn> to a
[=dictionary|dictionary definition=] if

1. |D| [=conforms=] to the definition,
1. there are no [=map/entries=] present that do not have a corresponding
   [=dictionary member=], and
1. [=dictionary=]-valued members [=strictly conform=] to their
   [=dictionary member=]'s type.

</div>


## Defaults ## {#sanitization-defaults}

The <dfn>built-in default config</dfn> is as follows:
```
{
  elements: [....],
  attributes: [....],
  comments: true,
}
```


# Security Considerations # {#security-considerations}

The Sanitizer API is intended to prevent DOM-based Cross-Site Scripting
by traversing a supplied HTML content and removing elements and attributes
according to a configuration. The specified API must not support
the construction of a Sanitizer object that leaves script-capable markup in
and doing so would be a bug in the threat model.

That being said, there are security issues which the correct usage of the
Sanitizer API will not be able to protect against and the scenarios will be
laid out in the following sections.

## Server-Side Reflected and Stored XSS ## {#server-side-xss}

<em>This section is not normative.</em>

The Sanitizer API operates solely in the DOM and adds a capability to traverse
and filter an existing DocumentFragment. The Sanitizer does not address
server-side reflected or stored XSS.

## DOM clobbering ## {#dom-clobbering}

<em>This section is not normative.</em>

DOM clobbering describes an attack in which malicious HTML confuses an
application by naming elements through `id` or `name` attributes such that
properties like `children` of an HTML element in the DOM are overshadowed by
the malicious content.

The Sanitizer API does not protect DOM clobbering attacks in its
default state, but can be configured to remove `id` and `name` attributes.

## XSS with Script gadgets ## {#script-gadgets}

<em>This section is not normative.</em>

Script gadgets are a technique in which an attacker uses existing application
code from popular JavaScript libraries to cause their own code to execute.
This is often done by injecting innocent-looking code or seemingly inert
DOM nodes that is only parsed and interpreted by a framework which then
performs the execution of JavaScript based on that input.

The Sanitizer API can not prevent these attacks, but requires page authors to
explicitly allow unknown elements in general, and authors must additionally
explicitly configure unknown attributes and elements and markup that is known
to be widely used for templating and framework-specific code,
like `data-` and `slot` attributes and elements like `<slot>` and `<template>`.
We believe that these restrictions are not exhaustive and encourage page
authors to examine their third party libraries for this behavior.

## Mutated XSS ## {#mutated-xss}

<em>This section is not normative.</em>

Mutated XSS or mXSS describes an attack based on parser context mismatches
when parsing an HTML snippet without the correct context. In particular,
when a parsed HTML fragment has been serialized to a string, the string is
not guaranteed to be parsed and interpreted exactly the same when inserted
into a different parent element. An example for carrying out such an attack
is by relying on the change of parsing behavior for foreign content or
misnested tags.

The Sanitizer API offers help against Mutated XSS, but relies on some amount of
cooperation by the developers. The `sanitize()` function does not handle strings
and is therefore unaffected. The `setHTML` function combines sanitization
with DOM modification and can implicitly apply the correct context. The
`sanitizeFor()` function combines parsing and sanitization, and relies on the
developer to supply the correct context for the eventual application of its
result.

If the data to be sanitized is available as a node tree, we encourage authors
to use the `sanitize()` function of the API which returns a
DocumentFragment and avoids risks that come with serialization and additional
parsing. Directly operating on a fragment after sanitization also comes with a
performance benefit, as the cost of additional serialization and parsing is
avoided.

A more complete treatement of mXSS can be found in [[MXSS]].

# Acknowledgements # {#ack}

Cure53's [[DOMPURIFY]] is a clear inspiration for the API this document
describes, as is Internet Explorer's {{window.toStaticHTML()}}.


