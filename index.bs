<pre class="metadata">
Title: HTML Sanitizer API
Status: CG-DRAFT
Group: WICG
URL: https://wicg.github.io/sanitizer-api/
Repository: WICG/sanitizer-api
Shortname: sanitizer-api
Level: 1
Editor: Frederik Braun 68466, Mozilla, fbraun@mozilla.com, https://frederik-braun.com
Editor: Mario Heiderich, Cure53, mario@cure53.de, https://cure53.de
Editor: Daniel Vogelheim, Google LLC, vogelheim@google.com, https://www.google.com
Editor: Tom Schuster, Mozilla, tschuster@mozilla.com, https://mozilla.com
Abstract:
  This document specifies a set of APIs which allow developers to take
  untrusted HTML input and sanitize it for safe insertion into a document's
  DOM.
Indent: 2
Work Status: exploring
Boilerplate: omit conformance
Markup Shorthands: css off, markdown on
</pre>
<pre class="link-defaults">
spec:html; type:attribute; text: innerHTML
spec:dom; type:method; text: createDocumentFragment
spec:html; type:dfn; text: template contents
spec:infra; type:dfn; text: user agent
</pre>
<pre class="anchors">
text: window.toStaticHTML(); type: method; url: https://msdn.microsoft.com/en-us/library/cc848922(v=vs.85).aspx
text: parse HTML from a string; type: dfn; url: https://html.spec.whatwg.org/#parse-html-from-a-string
text: HTML fragment parsing algorithm; type: dfn; url: https://html.spec.whatwg.org/#html-fragment-parsing-algorithm
text: global attribute; type: dfn; url: https://html.spec.whatwg.org/multipage/dom.html#global-attributes
text: custom data attribute; type: dfn; url: https://html.spec.whatwg.org/multipage/dom.html#custom-data-attribute
text: report a warning to the console; type: dfn; url: https://console.spec.whatwg.org/#report-a-warning-to-the-console
</pre>
<pre class="biblio">
{
  "DOMPURIFY": {
    "href": "https://github.com/cure53/DOMPurify",
    "title": "DOMPurify",
    "publisher": "Cure53"
  },
  "MXSS": {
    "href": "https://cure53.de/fp170.pdf",
    "title": "mXSS Attacks: Attacking well-secured Web-Applications by using innerHTML Mutations",
    "publisher": "Ruhr-Universit√§t Bochum"
  },
  "SafeMathML": {
    "href": "https://w3c.github.io/mathml-docs/mathml-safe-list",
    "title": "MathML Safe List",
    "publisher": "W3C Math Working Group"
  },
  "HTMLSanitizer": {
  "href": "https://www.bucksch.org/1/projects/mozilla/108153/",
  "title": "HTML Sanitizer",
  "publisher": "Ben Bucksch"
  }
}
</pre>
<style>
/* Boxes around algorithms. */
[data-algorithm]:not(.heading) {
  padding: .5em;
  border: thin solid #ddd; border-radius: .5em;
  margin: .5em calc(-0.5em - 1px);
}
[data-algorithm]:not(.heading) > :first-child { margin-top: 0; }
[data-algorithm]:not(.heading) > :last-child { margin-bottom: 0; }
[data-algorithm] [data-algorithm] { margin: 1em 0; }

/* Support [=Comment=] references. */
p:has(a[href="#comment"]) { color: var(--noteheading-text); }
a[href="#comment"] { text-transform: uppercase; }
</style>


# Introduction # {#intro}

<em>This section is not normative.</em>

Web applications often need to work with strings of HTML on the client side,
perhaps as part of a client-side templating solution, perhaps as part of
rendering user generated content, etc. It is difficult to do so in a safe way.
The naive approach of joining strings together and stuffing them into
an {{Element}}'s {{Element/innerHTML}} is fraught with risk, as it can cause
JavaScript execution in a number of unexpected ways.

Libraries like [[DOMPURIFY]] attempt to manage this problem by carefully
parsing and sanitizing strings before insertion, by constructing a DOM and
filtering its members through an allow-list. This has proven to be a fragile
approach, as the parsing APIs exposed to the web don't always map in
reasonable ways to the browser's behavior when actually rendering a string as
HTML in the "real" DOM. Moreover, the libraries need to keep on top of
browsers' changing behavior over time; things that once were safe may turn
into time-bombs based on new platform-level features.

The browser has a fairly good idea of when it is going to
execute code. We can improve upon the user-space libraries by teaching the
browser how to render HTML from an arbitrary string in a safe manner, and do
so in a way that is much more likely to be maintained and updated along with
the browser's own changing parser implementation. This document outlines an
API which aims to do just that.

## Goals ## {#goals}

*   Mitigate the risk of DOM-based cross-site scripting attacks by providing
    developers with mechanisms for handling user-controlled HTML which prevent
    direct script execution upon injection.

*   Make HTML output safe for use within the current user agent, taking into
    account its current understanding of HTML.

*   Allow developers to override the default set of elements and attributes.
    Adding certain elements and attributes can prevent
    <a href="https://github.com/google/security-research-pocs/tree/master/script-gadgets">script gadget</a>
    attacks.

## API Summary ## {#api-summary}

The Sanitizer API offers functionality to parse a string containing HTML into
a DOM tree, and to filter the resulting tree according to a user-supplied
configuration. The methods come in two by two flavours:

* <dfn>Safe and unsafe</dfn>: The "safe" methods will not generate any markup that
  executes script. That is, they should be safe from XSS. The "unsafe" methods
  will parse and filter whatever they're supposed to.
  See also: [[#security-considerations]].
* Context: Methods are defined on {{Element}} and {{ShadowRoot}} and will
  replace these {{Node}}'s children, and are largely analogous to {{Element/innerHTML}}.
  There are also static methods on the {{Document}}, which parse an entire
  document are largely analogous to {{DOMParser}}.{{parseFromString()}}.


# Framework # {#framework}

## Sanitizer API ## {#sanitizer-api}

The {{Element}} interface defines two methods, {{Element/setHTML()}} and
{{Element/setHTMLUnsafe()}}. Both of these take a {{DOMString}} with HTML
markup, and an optional configuration.

<pre class="idl extract">
partial interface Element {
  [CEReactions] undefined setHTMLUnsafe((TrustedHTML or DOMString) html, optional SetHTMLUnsafeOptions options = {});
  [CEReactions] undefined setHTML(DOMString html, optional SetHTMLOptions options = {});
};
</pre>

<div algorithm>
{{Element}}'s <dfn for="Element" method export>setHTMLUnsafe(|html|, |options|)</dfn> method steps are:

1. Let |compliantHTML| be the result of invoking the [$Get Trusted Type compliant string$] algorithm with
   {{TrustedHTML}}, [=this=]'s [=relevant global object=], |html|, "Element setHTMLUnsafe", and "script".
1. Let |target| be [=this=]'s [=template contents=] if [=this=] is a
   {{HTMLTemplateElement|template}} element; otherwise [=this=].
1. [=Set and filter HTML=] given |target|, [=this=], |compliantHTML|, |options|, and false.

</div>

<div algorithm>
{{Element}}'s <dfn for="Element" method export>setHTML(|html|, |options|)</dfn> method steps are:

1. Let |target| be [=this=]'s [=template contents=] if [=this=] is a
   {{HTMLTemplateElement|template}}; otherwise [=this=].
1. [=Set and filter HTML=] given |target|, [=this=], |html|, |options|, and true.

</div>

<pre class="idl extract">
partial interface ShadowRoot {
  [CEReactions] undefined setHTMLUnsafe((TrustedHTML or DOMString) html, optional SetHTMLUnsafeOptions options = {});
  [CEReactions] undefined setHTML(DOMString html, optional SetHTMLOptions options = {});
};
</pre>

These methods are mirrored on the {{ShadowRoot}}:

<div algorithm>
{{ShadowRoot}}'s <dfn for="ShadowRoot" method export>setHTMLUnsafe(|html|, |options|)</dfn> method steps are:

1. Let |compliantHTML| be the result of invoking the [$Get Trusted Type compliant string$] algorithm with
   {{TrustedHTML}}, [=this=]'s [=relevant global object=], |html|, "ShadowRoot setHTMLUnsafe", and "script".
1. [=Set and filter HTML=] using [=this=],
   [=this=]'s [=shadow host=] (as context element),
   |compliantHTML|, |options|, and false.

</div>

<div algorithm>
{{ShadowRoot}}'s <dfn for="ShadowRoot" method export>setHTML(|html|, |options|)</dfn> method steps are:

1. [=Set and filter HTML=] using [=this=] (as target), [=this=] (as context element),
   |html|, |options|, and true.

</div>

The {{Document}} interface gains two new methods which parse an entire {{Document}}:

<pre class="idl extract">
partial interface Document {
  static Document parseHTMLUnsafe((TrustedHTML or DOMString) html, optional SetHTMLUnsafeOptions options = {});
  static Document parseHTML(DOMString html, optional SetHTMLOptions options = {});
};
</pre>

<div algorithm>
The <dfn for="Document" method export>parseHTMLUnsafe(|html|, |options|)</dfn> method steps are:

1. Let |compliantHTML| be the result of invoking the [$Get Trusted Type compliant string$] algorithm with
   {{TrustedHTML}}, [=this=]'s [=relevant global object=], |html|, "Document parseHTMLUnsafe", and "script".
1. Let |document| be a new {{Document}}, whose [=Document/content type=] is "text/html".

   Note: Since |document| does not have a browsing context, scripting is disabled.
1. Set |document|'s [=allow declarative shadow roots=] to true.
1. [=Parse HTML from a string=] given |document| and |compliantHTML|.
1. Let |sanitizer| be the result of calling [=get a sanitizer instance from options=]
   with |options| and false.
1. Call [=sanitize=] on |document| with |sanitizer| and false.
1. Return |document|.

</div>


<div algorithm>
The <dfn for="Document" method export>parseHTML(|html|, |options|)</dfn> method steps are:

1. Let |document| be a new {{Document}}, whose [=Document/content type=] is "text/html".

   Note: Since |document| does not have a browsing context, scripting is disabled.
1. Set |document|'s [=allow declarative shadow roots=] to true.
1. [=Parse HTML from a string=] given |document| and |html|.
1. Let |sanitizer| be the result of calling [=get a sanitizer instance from options=]
   with |options| and true.
1. Call [=sanitize=] on |document| with |sanitizer| and true.
1. Return |document|.

</div>

## SetHTML options and the configuration object. ## {#configobject}

The family of {{Element/setHTML()}}-like methods all accept an options
dictionary. Right now, only one member of this dictionary is defined:

<pre class=idl>
enum SanitizerPresets { "default" };
dictionary SetHTMLOptions {
  (Sanitizer or SanitizerConfig or SanitizerPresets) sanitizer = "default";
};
dictionary SetHTMLUnsafeOptions {
  (Sanitizer or SanitizerConfig or SanitizerPresets) sanitizer = {};
};
</pre>

The {{Sanitizer}} configuration object encapsulates a filter configuration.
The same configuration can be used with both <a lt="safe and unsafe">"safe"
or "unsafe"</a> methods, where the "safe" methods perform an implicit
{{removeUnsafe}} operation on the passed in configuration and have a default
configuration when none is passed. The default differs between "safe" and
"unsafe" methods: The "safe" methods are aiming to be safe by default and
have a restrictive default, while the "unsafe" methods are unrestricted by
default. The intent for configuration use is
that one (or a few) configurations will be built-up early on in a page's
lifetime, and can then be used whenever needed. This allows implementations
to pre-process configurations.

The configuration object can be queried to return a configuration dictionary.
It can also be modified directly.

<pre class=idl>
[Exposed=Window]
interface Sanitizer {
  constructor(optional (SanitizerConfig or SanitizerPresets) configuration = "default");

  // Query configuration:
  SanitizerConfig get();

  // Modify a Sanitizer's lists and fields:
  boolean allowElement(SanitizerElementWithAttributes element);
  boolean removeElement(SanitizerElement element);
  boolean replaceElementWithChildren(SanitizerElement element);
  boolean allowAttribute(SanitizerAttribute attribute);
  boolean removeAttribute(SanitizerAttribute attribute);
  boolean setComments(boolean allow);
  boolean setDataAttributes(boolean allow);

  // Remove markup that executes script.
  boolean removeUnsafe();
};
</pre>

A {{Sanitizer}} has an associated {{SanitizerConfig}} <dfn for="Sanitizer">configuration</dfn>.

<div algorithm>
The <dfn for="Sanitizer" constructor export>constructor(|configuration|)</dfn>
method steps are:

1. If |configuration| is a {{SanitizerPresets}} [=string=], then:
    1. [=Assert=]: |configuration| [=is=] {{SanitizerPresets/default}}.
    1. Set |configuration| to the [=built-in safe default configuration=].
1. Let |valid| be the return value of [=set a configuration=] with
   |configuration| and true on [=this=].
1. If |valid| is false, then throw a {{TypeError}}.

</div>

<div algorithm>
The <dfn for="Sanitizer" method export>get()</dfn> method steps are:

<div class=note><span class=marker>Note:</span>
Outside of the get() method, the order of the Sanitizer's elements and attributes is unobservable.
By explicitly sorting the result of this method, we give implementations the opportunity to optimize by, for example, using unordered sets internally.
</div>

1. Let |config| be [=this=]'s [=Sanitizer/configuration=].
1. If |config|["{{SanitizerConfig/elements}}"] [=map/exists=]:
    1. [=list/iterate|For any=] |element| of |config|["{{SanitizerConfig/elements}}"]:
        1. If |element|["{{SanitizerElementNamespaceWithAttributes/attributes}}"] [=map/exists=]:
            1. Set |element|["{{SanitizerElementNamespaceWithAttributes/attributes}}"] to the result of [=list/sort in ascending order=]
               |element|["{{SanitizerElementNamespaceWithAttributes/attributes}}"], with |attrA| being [=SanitizerConfig/less than item=] |attrB|.
        1. If |element|["{{SanitizerElementNamespaceWithAttributes/removeAttributes}}"] [=map/exists=]:
            1. Set |element|["{{SanitizerElementNamespaceWithAttributes/removeAttributes}}"] to the result of [=list/sort in ascending order=]
               |element|["{{SanitizerElementNamespaceWithAttributes/removeAttributes}}"], with |attrA| being [=SanitizerConfig/less than item=] |attrB|.
    1. Set |config|["{{SanitizerConfig/elements}}"] to the result of [=list/sort in ascending order=] |config|["{{SanitizerConfig/elements}}"],
       with |elementA| being [=SanitizerConfig/less than item=] |elementB|.
1. If |config|["{{SanitizerConfig/removeElements}}"] [=map/exists=]:
  1. Set |config|["{{SanitizerConfig/removeElements}}"] to the result of [=list/sort in ascending order=] |config|["{{SanitizerConfig/removeElements}}"],
     with |elementA| being [=SanitizerConfig/less than item=] |elementB|.
1. If |config|["{{SanitizerConfig/replaceWithChildrenElements}}"] [=map/exists=]:
  1. Set |config|["{{SanitizerConfig/replaceWithChildrenElements}}"] to the result of [=list/sort in ascending order=] |config|["{{SanitizerConfig/replaceWithChildrenElements}}"],
     with |elementA| being [=SanitizerConfig/less than item=] |elementB|.
1. If |config|["{{SanitizerConfig/attributes}}"] [=map/exists=]:
  1. Set |config|["{{SanitizerConfig/attributes}}"] to the result of [=list/sort in ascending order=] |config|["{{SanitizerConfig/attributes}}"],
     with |attrA| being [=SanitizerConfig/less than item=] |attrB|.
1. If |config|["{{SanitizerConfig/removeAttributes}}"] [=map/exists=]:
  1. Set |config|["{{SanitizerConfig/removeAttributes}}"] to the result of [=list/sort in ascending order=] |config|["{{SanitizerConfig/removeAttributes}}"],
     with |attrA| being [=SanitizerConfig/less than item=] |attrB|.
1. Return |config|.

</div>

<div algorithm>
The <dfn for="Sanitizer" method export>allowElement(|element|)</dfn> method steps are to [=allow an element=] with |element| and [=this=]'s [=Sanitizer/configuration=].
</div>

<div algorithm>
The <dfn for="Sanitizer" method export>removeElement(|element|)</dfn> method steps are
to [=remove an element=] with |element| and [=this=]'s [=Sanitizer/configuration=].
</div>

<div algorithm>
The <dfn for="Sanitizer" method export>replaceElementWithChildren(|element|)</dfn> method steps are to [=replace an element with its children=] with |element| and [=this=]'s [=Sanitizer/configuration=].
</div>

<div algorithm>
The <dfn for="Sanitizer" method export>allowAttribute(|attribute|)</dfn> method steps are to [=allow an attribute=] with |attribute| and [=this=]'s [=Sanitizer/configuration=].
</div>


<div algorithm>
The <dfn for="Sanitizer" method export>removeAttribute(|attribute|)</dfn> method steps are to [=Sanitizer/remove an attribute=] with |attribute| and [=this=]'s [=Sanitizer/configuration=].
</div>

<div algorithm>
The <dfn for="Sanitizer" method export>setComments(|allow|)</dfn> method steps to [=set comments=] with |allow| and [=this=]'s [=Sanitizer/configuration=].
</div>

<div algorithm>
The <dfn for="Sanitizer" method export>setDataAttributes(|allow|)</dfn> method steps are to [=set data attributes=] with |allow| and [=this=]'s [=Sanitizer/configuration=].
</div>

<div algorithm>
The <dfn for="Sanitizer" method export>removeUnsafe()</dfn> method steps are to
update [=this=]'s [=Sanitizer/configuration=] with the result of calling [=remove unsafe=]
on [=this=]'s [=Sanitizer/configuration=].
</div>

## The Configuration Dictionary ## {#config}

<pre class=idl>
dictionary SanitizerElementNamespace {
  required DOMString name;
  DOMString? _namespace = "http://www.w3.org/1999/xhtml";
};

// Used by "elements"
dictionary SanitizerElementNamespaceWithAttributes : SanitizerElementNamespace {
  sequence&lt;SanitizerAttribute> attributes;
  sequence&lt;SanitizerAttribute> removeAttributes;
};

typedef (DOMString or SanitizerElementNamespace) SanitizerElement;
typedef (DOMString or SanitizerElementNamespaceWithAttributes) SanitizerElementWithAttributes;

dictionary SanitizerAttributeNamespace {
  required DOMString name;
  DOMString? _namespace = null;
};
typedef (DOMString or SanitizerAttributeNamespace) SanitizerAttribute;

dictionary SanitizerConfig {
  sequence&lt;SanitizerElementWithAttributes> elements;
  sequence&lt;SanitizerElement> removeElements;
  sequence&lt;SanitizerElement> replaceWithChildrenElements;

  sequence&lt;SanitizerAttribute> attributes;
  sequence&lt;SanitizerAttribute> removeAttributes;

  boolean comments;
  boolean dataAttributes;
};
</pre>

## Configuration Invariants ## {#invariants}

Configurations can and ought to be modified by developers to suit their
purposes. Options are to write a new [[#config|configuration dictionary]] from
scratch, to modify an existing {{Sanitizer}}'s configuration by using the
modifier methods, or to {{Sanitizer/get()}} an existing {{Sanitizer}}'s
[[#config|configuration]]  as a dictionary and modify the dictionary and then
create a new {{Sanitizer}} with it.

An empty configuration allows everything (when called with the "unsafe" methods like
{{Element/setHTMLUnsafe}}).
A configuration `"default"` contains a [=built-in safe default configuration=]. Note
that "safe" and "unsafe" sanitizer methods have different defaults.

Not all configuration dictionaries are valid. A valid configuration avoids redundancy
(like specifying the same element to be allowed twice) and contradictions (like specifying an
element to be both removed and allowed.)

Several conditions need to hold for a configuration to be valid:

- Mixing global allow- and remove-lists:
  - {{SanitizerConfig/elements}} or {{SanitizerConfig/removeElements}} can exist,
    but not both.
    If both are missing, this is equivalent to {{SanitizerConfig/removeElements}}
    [=map/set=] to &laquo; &raquo;.
  - {{SanitizerConfig/attributes}} or {{SanitizerConfig/removeAttributes}} can exist,
    but not both.
    If both are missing, this is equivalent to {{SanitizerConfig/removeAttributes}}
    [=map/set=] to &laquo; &raquo;.
  - {{SanitizerConfig/dataAttributes}} is conceptually an extension of the
    {{SanitizerConfig/attributes}} allow-list. The {{SanitizerConfig/dataAttributes}}
    attribute is only allowed when a {{SanitizerConfig/attributes}} list is used.
- Duplicate entries between different global lists:
  - There are no duplicate entries (i.e., no same elements) between
    {{SanitizerConfig/elements}}, {{SanitizerConfig/removeElements}}, or
    {{SanitizerConfig/replaceWithChildrenElements}}.
  - There are no duplicate entries (i.e., no same attributes) between
    {{SanitizerConfig/attributes}} or {{SanitizerConfig/removeAttributes}}.
- Duplicate entries on the same element:
  - There are no duplicate entries between {{SanitizerElementNamespaceWithAttributes/attributes}}
    and {{SanitizerElementNamespaceWithAttributes/removeAttributes}} on the same element.

The {{SanitizerConfig/elements}} element allow-list can also specify allowing or removing
attributes for a given element. This is meant to mirror [[HTML]]'s structure, which knows
both [=/global attributes=] as well as local <a spec=dom>attributes</a> that apply to a
specific element. Global and local attributes can be mixed, but note that ambiguous
configurations where a particular attribute would be allowed by one list and forbidden by another,
are generally invalid.

<table class=data>
<tr>
 <td></td>
 <th>global {{SanitizerConfig/attributes}}</th>
 <th>global {{SanitizerConfig/removeAttributes}}</th>
</tr>
<tr>
 <th>local {{SanitizerElementNamespaceWithAttributes/attributes}}</th>
 <td class=long>An attribute is allowed if it matches either list. No duplicates are allowed.</td>
 <td class=long>An attribute is only allowed if it's in the local allow list.
   No duplicate entries between global remove and local allow lists are allowed.
   Note that the global remove list has no function for this particular element, but may well
   apply to other elements that do not have a local allow list.</td>
</tr>
<tr>
 <th>local {{SanitizerElementNamespaceWithAttributes/removeAttributes}}</th>
 <td class=long>An attribute is allowed if it's in the global allow-list, but not in the local
   remove-list. Local remove must be a subset of the global allow lists. </td>
 <td class=long>An attribute is allowed if it is in neither list.
   No duplicate entries between global remove and local remove lists are allowed.</td>
</tr>
</table>

Please note the asymmetry where mostly no duplicates between global and per-element lists are
permitted, but in the case of a global allow-list and a per-element remove-list the latter must
be a subset of the former. An excerpt of the table above, only focusing on duplicates, is as
follows:

<table class=data>
<tr>
 <td></td>
 <th>global {{SanitizerConfig/attributes}}</th>
 <th>global {{SanitizerConfig/removeAttributes}}</th>
</tr>
<tr>
 <th>local {{SanitizerElementNamespaceWithAttributes/attributes}}</th>
 <td class=long>No duplicates are allowed.</td>
 <td class=long>No duplicates are allowed.
</tr>
<tr>
 <th>local {{SanitizerElementNamespaceWithAttributes/removeAttributes}}</th>
 <td class=long>Local remove must be a subset of the global allow lists. </td>
 <td class=long>No duplicates are allowed.</td>
</tr>
</table>

The {{SanitizerConfig/dataAttributes}} setting allows [=custom data attributes=]. The rules
above easily extends to [=custom data attributes=] if one considers
{{SanitizerConfig/dataAttributes}} to be an allow-list:

<table class=data>
<tr>
 <td></td>
 <th>global {{SanitizerConfig/attributes}} and {{SanitizerConfig/dataAttributes}} set</th>
</tr>
<tr>
 <th>local {{SanitizerElementNamespaceWithAttributes/attributes}}</th>
 <td class=long>All [=custom data attributes=] are allowed. No [=custom data attributes=] may
   be listed in any allow-list, as that would mean a duplicate entry.</td>
</tr>
<tr>
 <th>local {{SanitizerElementNamespaceWithAttributes/removeAttributes}}</th>
 <td class=long>A [=custom data attribute=] is allowed, unless it's listed in the local
   remove-list.
   No [=custom data attribute=] may be listed in the global allow-list, as that would mean a
   duplicate entry.</td>
</tr>
</table>

Putting these rules in words:

* Duplicates and interactions between global and local lists:
  * If a global {{SanitizerConfig/attributes}} allow list exists, then all element's local lists:
    * If a local {{SanitizerElementNamespaceWithAttributes/attributes}} allow lists exists,
        there may be no duplicate entries between these lists.
    * If a local {{SanitizerElementNamespaceWithAttributes/removeAttributes}} remove lists exists,
        then all its entries must also be listed in the global {{SanitizerConfig/attributes}}
        allow list.
    * If {{SanitizerConfig/dataAttributes}} is true, then no [=custom data attributes=] may be
        listed in any of the allow-lists.
  * If a global {{SanitizerConfig/removeAttributes}} remove list exists, then:
    * If a local {{SanitizerElementNamespaceWithAttributes/attributes}} allow lists exists,
        there may be no duplicate entries between these lists.
    * If a local {{SanitizerElementNamespaceWithAttributes/removeAttributes}} remove lists exists,
        there may be no duplicate entries between these lists.
    * {{SanitizerConfig/dataAttributes}} must be absent.

<div algorithm>
A {{SanitizerConfig}} |config| is <dfn for=SanitizerConfig>valid</dfn> if all of the following
conditions hold:

1. The |config| has either an {{SanitizerConfig/elements}} or a {{SanitizerConfig/removeElements}}
    [=map/key=], but not both.
1. The |config| has either an {{SanitizerConfig/attributes}} or a {{SanitizerConfig/removeAttributes}}
    [=map/key=], but not both.
1. [=Assert=]: All {{SanitizerElementNamespaceWithAttributes}}, {{SanitizerElementNamespace}}, and
    {{SanitizerAttributeNamespace}} items in |config| are canonical, meaning they have been run
    through [=canonicalize a sanitizer element=] or [=canonicalize a sanitizer attribute=],
    as appropriate.
1. None of |config|[{{SanitizerConfig/elements}}], |config|[{{SanitizerConfig/removeElements}}],
    |config|[{{SanitizerConfig/replaceWithChildrenElements}}],
    |config|[{{SanitizerConfig/attributes}}], or
    |config|[{{SanitizerConfig/removeAttributes}}], if they [=map/exist=],
    [=SanitizerConfig/has duplicates=].
1. If both |config|[{{SanitizerConfig/elements}}] and
    |config|[{{SanitizerConfig/replaceWithChildrenElements}}] [=map/exist=], then
    the [=SanitizerConfig/intersection=] of |config|[{{SanitizerConfig/elements}}] and
    |config|[{{SanitizerConfig/replaceWithChildrenElements}}] is [=list/empty=].
1. If both |config|[{{SanitizerConfig/removeElements}}] and
    |config|[{{SanitizerConfig/replaceWithChildrenElements}}] [=map/exist=], then
    the [=SanitizerConfig/intersection=] of |config|[{{SanitizerConfig/removeElements}}] and
    |config|[{{SanitizerConfig/replaceWithChildrenElements}}] is [=list/empty=].
1. If |config|[{{SanitizerConfig/attributes}}] [=map/exists=]:
    1. If |config|[{{SanitizerConfig/elements}}] [=map/exists=]:
        1. [=list/iterate|For each=] |element| of |config|[{{SanitizerConfig/elements}}]:
            1. Neither |element|[{{SanitizerElementNamespaceWithAttributes/attributes}}] nor
               |element|[{{SanitizerElementNamespaceWithAttributes/removeAttributes}}], if they exist, [=SanitizerConfig/has duplicates=].
            1. The [=set/intersection=] of |config|[{{SanitizerConfig/attributes}}] and
                |element|[{{SanitizerElementNamespaceWithAttributes/attributes}}] [=with default=]
                &laquo; &raquo; is [=list/empty=].
            1. |element|[{{SanitizerElementNamespaceWithAttributes/removeAttributes}}]
                [=with default=] &laquo; &raquo; is a
                [=set/subset=] of |config|[{{SanitizerConfig/attributes}}].
            1. If {{SanitizerConfig/dataAttributes}} [=map/exists=] and
                {{SanitizerConfig/dataAttributes}} is true:
                1. |element|[{{SanitizerElementNamespaceWithAttributes/attributes}}] does not
                    contain a [=custom data attribute=].
    1. If {{SanitizerConfig/dataAttributes}} is true:
        1. |config|[{{SanitizerConfig/attributes}}] does not contain
            a [=custom data attribute=].
1. If |config|[{{SanitizerConfig/removeAttributes}}] [=map/exists=]:
    1. If |config|[{{SanitizerConfig/elements}}] [=map/exists=],
       then [=list/iterate|for each=] |element| of |config|[{{SanitizerConfig/elements}}]:
        1. Neither |element|[{{SanitizerElementNamespaceWithAttributes/attributes}}] nor
           |element|[{{SanitizerElementNamespaceWithAttributes/removeAttributes}}], if they exist, [=SanitizerConfig/has duplicates=].
        1. The [=set/intersection=] of |config|[{{SanitizerConfig/removeAttributes}}] and
            |element|[{{SanitizerElementNamespaceWithAttributes/attributes}}] [=with default=]
            &laquo; &raquo; is [=list/empty=].
        1. The [=set/intersection=] of |config|[{{SanitizerConfig/removeAttributes}}] and
            |element|[{{SanitizerElementNamespaceWithAttributes/removeAttributes}}] [=with default=]
            &laquo; &raquo; is [=list/empty=].
    1. |config|[{{SanitizerConfig/dataAttributes}}] does not [=map/exist=].

</div>

Note: [=set a configuration|Setting a configuration=] from a [=dictionary=] will do a bit
normalization. In particular, if both allow- and remove-lists are missing, it will interpret this
as an empty remove-list. So `{}` itself is not a [=SanitizerConfig/valid=] configuration, but it
will be normalized to `{removeElements:[],removeAttributes:[]}`, which is. This normalization step
was chosen in order to have a missing dictionary be consistent with an empty one, i.e., to have
`setHTMLUnsafe(txt)` be consistent with `setHTMLUnsafe(txt, {sanitizer: {}})`.

# Algorithms # {#algorithms}

<div algorithm>
To <dfn>set and filter HTML</dfn>, given an {{Element}} or {{DocumentFragment}}
|target|, an {{Element}} |contextElement|, a [=string=] |html|, and a
[=dictionary=] |options|, and a [=boolean=] |safe|:

1. If |safe| and |contextElement|'s [=Element/local name=] is "`script`" and
   |contextElement|'s [=Element/namespace=] is the [=HTML namespace=] or the
   [=SVG namespace=], then return.
1. Let |sanitizer| be the result of calling [=get a sanitizer instance from options=]
   with |options| and |safe|.
1. Let |newChildren| be the result of the [=HTML fragment parsing algorithm=]
   given |contextElement|, |html|, and true.
1. Let |fragment| be a new {{DocumentFragment}} whose [=node document=] is |contextElement|'s [=node document=].
1. [=list/iterate|For each=] |node| in |newChildren|, [=list/append=] |node| to |fragment|.
1. Run [=sanitize=] on |fragment| using |sanitizer| and |safe|.
1. [=Replace all=] with |fragment| within |target|.

</div>

<div algorithm>
To <dfn for="SanitizerConfig">get a sanitizer instance from options</dfn> from
a [=dictionary=] |options| with a [=boolean=] |safe|:

Note: This algorithm works for both {{SetHTMLOptions}} and
    {{SetHTMLUnsafeOptions}}. They only differ in the defaults.

1. Let |sanitizerSpec| be "{{SanitizerPresets/default}}".
1. If |options|["{{SetHTMLOptions/sanitizer}}"] [=map/exists=], then:
   1. Set |sanitizerSpec| to |options|["{{SetHTMLOptions/sanitizer}}"]
1. [=Assert=]: |sanitizerSpec| is either a {{Sanitizer}} instance,
   a [=string=] which is a {{SanitizerPresets}} member, or a [=dictionary=].
1. If |sanitizerSpec| is a [=string=]:
   1. [=Assert=]: |sanitizerSpec| [=is=] "{{SanitizerPresets/default}}"
   1. Set |sanitizerSpec| to the [=built-in safe default configuration=].
1. [=Assert=]: |sanitizerSpec| is either a {{Sanitizer}} instance,
   or a [=dictionary=].
1. If |sanitizerSpec| is a [=dictionary=]:
   1. Let |sanitizer| be a new {{Sanitizer}} instance.
   1. Let |setConfigurationResult| be the result of [=set a configuration=]
      with |sanitizerSpec| and [=boolean/not=] |safe| on |sanitizer|.
   1. If |setConfigurationResult| is false, [=throw=] a {{TypeError}}.
   1. Set |sanitizerSpec| to |sanitizer|.
1. [=Assert=]: |sanitizerSpec| is a {{Sanitizer}} instance.
1. Return |sanitizerSpec|.

</div>

## Sanitize ## {#sanitization}

<div algorithm>
For the main <dfn>sanitize</dfn> operation, using a {{ParentNode}} |node|, a
{{Sanitizer}} |sanitizer|, and a [=boolean=] |safe|, run these steps:

1. Let |configuration| be the value of |sanitizer|'s [=Sanitizer/configuration=].
1. If |safe| is true, then set |configuration| to the result of calling [=remove unsafe=] on |configuration|.
1. Call [=sanitize core=] on |node|, |configuration|, and with [=handleJavascriptNavigationUrls=] set to |safe|.

</div>

<div algorithm="sanitize core">
The <dfn>sanitize core</dfn> operation,
using a {{ParentNode}} |node|, a {{SanitizerConfig}} |configuration|, and a
[=boolean=] <var><dfn>handleJavascriptNavigationUrls</dfn></var>, recurses over the DOM tree
beginning with |node|. It consistes of these steps:

1. [=list/iterate|For each=] |child| of |node|'s [=tree/children=]:
  1. [=Assert=]: |child| [=implements=] {{Text}}, {{Comment}}, {{Element}},
      or {{DocumentType}}.

     Note: Currently, this algorithm is only called on output of the HTML
           parser for which this assertion should hold. {{DocumentType}} should
           only occur for {{Document/parseHTML}} and {{Document/parseHTMLUnsafe}}.
           If in the future this algorithm will be used in different contexts,
           this assumption needs to be re-examined.
  1. If |child| [=implements=] {{DocumentType}}, then [=continue=].
  1. If |child| [=implements=] {{Text}}, then [=continue=].
  1. If |child| [=implements=] {{Comment}}:
    1. If |configuration|["{{SanitizerConfig/comments}}"] is not true,
       then [=/remove=] |child|.
  1. Otherwise:
    1. Let |elementName| be a {{SanitizerElementNamespace}} with |child|'s
       [=Element/local name=] and [=Element/namespace=].
    1. If |configuration|["{{SanitizerConfig/replaceWithChildrenElements}}"] [=map/exists=]
       and if |configuration|["{{SanitizerConfig/replaceWithChildrenElements}}"]
       [=SanitizerConfig/contains=] |elementName|:
      1. Call [=sanitize core=] on |child| with |configuration| and
          |handleJavascriptNavigationUrls|.
      1. Call [=replace all=] with |child|'s [=tree/children=] within |child|.
      1. [=Continue=].
    1. If |configuration|["{{SanitizerConfig/removeElements}}"] [=map/exists=] and
        |configuration|["{{SanitizerConfig/removeElements}}"]  [=SanitizerConfig/contains=]
        |elementName|:
      1. [=/Remove=] |child|.
      1. [=Continue=].
    1. If |configuration|["{{SanitizerConfig/elements}}"] [=map/exists=] and
        |configuration|["{{SanitizerConfig/elements}}"] does not
        [=SanitizerConfig/contain=] |elementName|:
      1. [=/Remove=] |child|.
      1. [=Continue=].
    1. If |elementName| [=string/is|equals=] &laquo;[ "`name`" &rightarrow; "`template`",
       "`namespace`" &rightarrow; [=HTML namespace=] ]&raquo;,
          then call [=sanitize core=] on |child|'s [=template contents=] with
          |configuration| and |handleJavascriptNavigationUrls|.
    1. If |child| is a [=shadow host=],
       then call [=sanitize core=] on |child|'s [=Element/shadow root=] with
       |configuration| and |handleJavascriptNavigationUrls|.
    1. Let |elementWithLocalAttributes| be &laquo; [] &raquo;.
    1. If |configuration|["{{SanitizerConfig/elements}}"] [=map/exists=] and
        |configuration|["{{SanitizerConfig/elements}}"] [=SanitizerConfig/contains=]
        |elementName|:
       1. Set |elementWithLocalAttributes| to
           |configuration|["{{SanitizerConfig/elements}}"][|elementName|].
    1. [=list/iterate|For each=] |attribute| in |child|'s [=Element/attribute list=]:
      1. Let |attrName| be a {{SanitizerAttributeNamespace}} with |attribute|'s
         [=Attr/local name=] and [=Attr/namespace=].

      1. If |elementWithLocalAttributes|["{{SanitizerElementNamespaceWithAttributes/removeAttributes}}"] [=map/with default=] &laquo; &raquo;
        [=SanitizerConfig/contains=] |attrName|:
          1. [=/remove an attribute|Remove=] |attribute|.
      1. Otherwise, if |configuration|["{{SanitizerConfig/attributes}}"] [=map/exists=]:
          1. If |configuration|["{{SanitizerConfig/attributes}}"] does not
              [=SanitizerConfig/contain=] |attrName| and
              |elementWithLocalAttributes|["{{SanitizerElementNamespaceWithAttributes/attributes}}"] [=map/with default=] &laquo; &raquo;
              does not [=SanitizerConfig/contain=] |attrName|, and if
              "data-" is not a [=code unit prefix=] of |attribute|'s [=Attr/local name=] and
              [=Attr/namespace=] is not `null` or
              |configuration|["{{SanitizerConfig/dataAttributes}}"] is not true:
              1. [=/remove an attribute|Remove=] |attribute|.
      1. Otherwise:
        1. If |elementWithLocalAttributes|["{{SanitizerElementNamespaceWithAttributes/attributes}}"]
          [=map/exists=] and |elementWithLocalAttributes|["{{SanitizerElementNamespaceWithAttributes/attributes}}"] does not [=SanitizerConfig/contain=] |attrName|:
          1. [=/remove an attribute|Remove=] |attribute|.

        1. Otherwise, if |configuration|["{{SanitizerConfig/removeAttributes}}"] [=SanitizerConfig/contains=] |attrName|:
              1. [=/remove an attribute|Remove=] |attribute|.

      1. If |handleJavascriptNavigationUrls|:
         1. If &laquo;[|elementName|, |attrName|]&raquo; matches an entry in
            the [=built-in navigating URL attributes list=], and if |attribute|
            [=contains a javascript: URL=], then [=/remove an attribute|remove=] |attribute|.
         1. If |child|'s [=Element/namespace=] [=string/is=] the
            [=MathML Namespace=] and |attr|'s [=Attr/local name=] [=string/is=]
            "`href`" and  |attr|'s [=Attr/namespace=] is `null` or the
            [=XLink namespace=] and |attr| [=contains a javascript: URL=],
            then [=/remove an attribute|remove=] |attribute|.
         1. If the [=built-in animating URL attributes list=]
            [=SanitizerConfig/contains=]
            &laquo;[|elementName|, |attrName|]&raquo; and |attr|'s
            [=get an attribute value|value=] [=string/is=] "`href`" or
            "`xlink:href`", then [=/remove an attribute|remove=] |attribute|.
    1. Call [=sanitize core=] on |child| with |configuration| and |handleJavascriptNavigationUrls|.

</div>

<div class=note>
<span class=marker>Note:</span> Current browsers support `javascript:` URLs
only when navigating. Since navigation itself is not an XSS threat we handle
navigation to `javascript:` URLs, but not navigations in general.

Declarative navigation falls into a handful of categories:

  1. Anchor elements. (`<a>` in HTML and SVG namespaces)
  1. Form elements that trigger navigation as part of the form action.
  1. [[MathML]] allows [any element to act as an anchor](
     https://www.w3.org/TR/MathML3/mathml.html#chapter2_fund.globatt).
  1. [[SVG11]] animation.

The first two are covered by the [=built-in navigating URL attributes list=].

The MathML case is covered by a seperate rule, because there is no formalism
in this spec to cover a "per-namespace global" rule.

The SVG animation case is covered by the
[=built-in animating URL attributes list=]. But since the interpretation of SVG animation elements depends on the animation target, and since during sanitization we cannot know what the final target will be, the [=sanitize=] algorithm blocks any animation of `href` attributes.

</div>

<div algorithm>
To determine whether an |attribute| <dfn>contains a javascript: URL</dfn>:
1. Let |url| be the result of running the [=basic URL parser=]
   on |attribute|'s [=get an attribute value|value=].
1. If |url| is `failure`, then return false.
1. Return whether |url|'s [=url/scheme=] [=string/is=] "`javascript`".

</div>

## Modify the Configuration ## {#configuration-modify}

The configuration modifier methods are methods on {{Sanitizer}} that modify its configuration.
They will maintain the validity criteria.
They return a boolean which informs the caller whether the configuration was modified or not.

<div class=example>
```js
let s = new Sanitizer({elements: ["div"]});
s.allowElement("p"); // Returns true.
div.setHTML("<div><p>", {sanitizer: s});  // Allows `<div>` and `<p>`.
```
</div>

<div class=example>
```js
let s = new Sanitizer({elements: ["div"]});
s.removeElement("p");  // Return false, as <p> was not previously allowed.
div.setHTML("<div><p>", {sanitizer: s});  // Allows `<div>`. `<p>` is removed.
```
</div>

<div algorithm>
To <dfn for="SanitizerConfig">allow an element</dfn>
{{SanitizerElementWithAttributes}} |element| with a {{SanitizerConfig}} |configuration|:

<div class=note><span class=marker>Note:</span>
This algorithm is relatively involved, because the element allow list may specifiy per-element
allow- or remove-lists for attributes. This requires that we distinguish 4 cases:

* Whether we have a global allow- or remove-list, and
* whether these lists already contain |element| or not.

</div>

1. Set |element| to the result of [=canonicalize a sanitizer element with attributes=] with
    |element|.
1. If |configuration|["{{SanitizerConfig/elements}}"] [=map/exists=]:
    1. Set |modified| to the result of [=SanitizerConfig/remove=] |element| from
       |configuration|["{{SanitizerConfig/replaceWithChildrenElements}}"].
    1. [=Comment=]: We need to make sure the per-element attributes do not overlap with global
        attributes.
    1. If |element|["{{SanitizerElementNamespaceWithAttributes/attributes}}"] [=map/exists=]:
        1. Set |element|["{{SanitizerElementNamespaceWithAttributes/attributes}}"] to
           [=SanitizerConfig/remove duplicates=] from |element|["{{SanitizerElementNamespaceWithAttributes/attributes}}"].
        1. If |configuration|["{{SanitizerConfig/attributes}}"] [=map/exists=]:
            1. Set |element|["{{SanitizerElementNamespaceWithAttributes/attributes}}"] to the
                [=set/difference=] of
                |element|["{{SanitizerElementNamespaceWithAttributes/attributes}}"] and
                |configuration|["{{SanitizerConfig/attributes}}"].
            1. If |configuration|["{{SanitizerConfig/dataAttributes}}"] is true:
                1. [=list/Remove=] all items |item| from
                    |element|["{{SanitizerElementNamespaceWithAttributes/attributes}}"]
                    where |item| is a [=custom data attribute=].
        1. If |configuration|["{{SanitizerConfig/removeAttributes}}"] [=map/exists=]:
            1. Set |element|["{{SanitizerElementNamespaceWithAttributes/attributes}}"] to the
                [=set/difference=] of
                |element|["{{SanitizerElementNamespaceWithAttributes/attributes}}"] and
                |configuration|["{{SanitizerConfig/removeAttributes}}"].
    1. If |element|["{{SanitizerElementNamespaceWithAttributes/removeAttributes}}"]
        [=map/exists=]:
        1. Set |element|["{{SanitizerElementNamespaceWithAttributes/removeAttributes}}"] to
               [=SanitizerConfig/remove duplicates=] from |element|["{{SanitizerElementNamespaceWithAttributes/removeAttributes}}"].
        1. If |configuration|["{{SanitizerConfig/attributes}}"] [=map/exists=]:
            1. Set |element|["{{SanitizerElementNamespaceWithAttributes/removeAttributes}}"] to the
                [=set/intersection=] of
                |element|["{{SanitizerElementNamespaceWithAttributes/removeAttributes}}"] and
                |configuration|["{{SanitizerConfig/attributes}}"].
        1. If |configuration|["{{SanitizerConfig/removeAttributes}}"] [=map/exists=]:
            1. Set |element|["{{SanitizerElementNamespaceWithAttributes/removeAttributes}}"] to the
                [=set/difference=] of
                |element|["{{SanitizerElementNamespaceWithAttributes/removeAttributes}}"] and
                |configuration|["{{SanitizerConfig/removeAttributes}}"].
    1. If |configuration|["{{SanitizerConfig/elements}}"] does not [=map/contain=] |element|:
        1. [=Comment=]: This is the case with a global allow-list that does not yet contain
            |element|.
        1. [=list/Append=] |element| to |configuration|["{{SanitizerConfig/elements}}"].
        1. Return true.
    1. [=Comment=]: This is the case with a global allow-list that already contains |element|.
    1. Let |current element| be the |item| in |configuration|["{{SanitizerConfig/elements}}"]
        where |item|[{{SanitizerElementNamespace/name}}] [=string/is|equals=]
        |element|[{{SanitizerElementNamespace/name}}]
        and |item|[{{SanitizerElementNamespace/namespace}}] [=string/is|equals=]
        |element|[{{SanitizerElementNamespace/namespace}}].
    1. If |element| [=map/equals=] |current element| then return |modified|.
    1. [=SanitizerConfig/Remove=] |element| from |configuration|["{{SanitizerConfig/elements}}"].
    1. [=list/Append=] |element| to |configuration|["{{SanitizerConfig/elements}}"]
    1. Return true.
1. Otherwise:
  1. If |element|["{{SanitizerElementNamespaceWithAttributes/attributes}}"] [=map/exists=] or
     |element|["{{SanitizerElementNamespaceWithAttributes/removeAttributes}}"] [=with default=] &laquo; &raquo;
     is not [=list/empty=]:
    1. The user agent may [=report a warning to the console=] that this operation is not supported.
    1. Return false.
  1. Set |modified| to the result of [=SanitizerConfig/remove=] |element| from
     |configuration|["{{SanitizerConfig/replaceWithChildrenElements}}"].
  1. If |configuration|["{{SanitizerConfig/removeElements}}"] does not [=map/contain=] |element|:
      1. [=Comment=]: This is the case with a global remove-list that does not contain |element|.
      1. Return |modified|.
  1. [=Comment=]: This is the case with a global remove-list that contains |element|.
  1. [=SanitizerConfig/Remove=] |element| from
      |configuration|["{{SanitizerConfig/removeElements}}"].
  1. Return true.

</div>

<div algorithm>
To <dfn for="Sanitizer">remove an element</dfn> {{SanitizerElement}} |element|
from a {{SanitizerConfig}} |configuration|:

<div class=note><span class=marker>Note:</span>
This method requires that we distinguish 4 cases:
* Whether we have a global allow- or remove-list,
* whether they already contain |element| or not.

</div>

1. Set |element| to the result of [=canonicalize a sanitizer element=] with |element|.
1. Set |modified| to the result of
    [=SanitizerConfig/remove=] |element| from
    |configuration|["{{SanitizerConfig/replaceWithChildrenElements}}"].
1. If |configuration|["{{SanitizerConfig/elements}}"] [=map/exists=]:
    1. If |configuration|["{{SanitizerConfig/elements}}"] [=map/contains=] |element|:
        1. [=Comment=]: We have a global allow list and it contains |element|.
        1. [=SanitizerConfig/Remove=] |element| from
            |configuration|["{{SanitizerConfig/elements}}"].
        1. Return true.
    1. [=Comment=]: We have a global allow list and it does not contain |element|.
    1. Return |modified|.
1. Otherwise:
    1. If |configuration|["{{SanitizerConfig/removeElements}}"] [=map/contains=] |element|:
        1. [=Comment=]: We have a global remove list and it already contains |element|.
        1. Return |modified|.
    1. [=Comment=]: We have a global remove list and it does not contain |element|.
    1. [=SanitizerConfig/Add=] |element| to |configuration|["{{SanitizerConfig/removeElements}}"].
    1. Return true.

</div>

<div algorithm>
To <dfn for="Sanitizer">replace an element with its children</dfn>
{{SanitizerElement}} |element| from a {{SanitizerConfig}} |configuration|:

1. Set |element| to the result of [=canonicalize a sanitizer element=] with |element|.
1. If |configuration|["{{SanitizerConfig/replaceWithChildrenElements}}"] [=map/contains=] |element|:
    1. Return false.
1. [=SanitizerConfig/Remove=] |element| from |configuration|["{{SanitizerConfig/removeElements}}"].
1. [=SanitizerConfig/Remove=] |element| from |configuration|["{{SanitizerConfig/elements}}"] list.
1. [=SanitizerConfig/Add=] |element| to |configuration|["{{SanitizerConfig/replaceWithChildrenElements}}"].
1. Return true.

</div>

<div algorithm>
To <dfn for="Sanitizer">allow an attribute</dfn> {{SanitizerAttribute}}
|attribute| on a {{SanitizerConfig}} |configuration|:

Note: This method distinguishes two cases, namely whether we have a global allow- or a global
remove-list. If add |attribute| to a global allow-list, we may need to do additional work to fix
up per-element allow- or remove-lists to maintain our validity criteria.

1. Set |attribute| to the result of [=canonicalize a sanitizer attribute=] with |attribute|.
1. If |configuration|["{{SanitizerConfig/attributes}}"] [=map/exists=]:
    1. [=Comment=]: If we have a global allow-list, we need to add |attribute|.
    1. If |configuration|["{{SanitizerConfig/dataAttributes}}"] is true and |attribute| is a
       [=custom data attribute=], then return false.
    1. If |configuration|["{{SanitizerConfig/attributes}}"] [=list/contains=] |attribute|
        return false.
    1. [=Comment=]: Fix-up per-element allow and remove lists.
    1. If |configuration|["{{SanitizerConfig/elements}}"] [=map/exists=]:
        1. [=list/iterate|For each=] |element| in |configuration|["{{SanitizerConfig/elements}}"]:
            1. If |element|["{{SanitizerElementNamespaceWithAttributes/attributes}}"]
               [=map/with default=] &laquo; &raquo; [=list/contains=] |attribute|:
                1. [=list/Remove=] |attribute| from
                    |element|["{{SanitizerElementNamespaceWithAttributes/attributes}}"].
            1. [=Assert=]: |element|["{{SanitizerElementNamespaceWithAttributes/removeAttributes}}"]
               [=map/with default=] &laquo; &raquo;
               does not [=list/contain=] |attribute|.
    1. [=list/Append=] |attribute| to |configuration|["{{SanitizerConfig/attributes}}"]
    1. Return true.
1. Otherwise:
    1. [=Comment=]: If we have a global remove-list, we need to remove |attribute|.
    1. If |configuration|["{{SanitizerConfig/removeAttributes}}"] does not [=list/contain=]
        |attribute|:
        1. Return false.
    1. [=list/Remove=] |attribute| from |configuration|["{{SanitizerConfig/removeAttributes}}"].
    1. Return true.

</div>


<div algorithm>
To <dfn for="Sanitizer">remove an attribute</dfn> SanitizerAttribute|attribute|
from a {{SanitizerConfig}} |configuration|:

Note: This method distinguishes two cases, namely whether we have a global allow- or a global
remove-list. If we add |attribute| to the global remove-list, we may need to do additional work
to fix up per-element allow- or remove-lists to maintain our validity criteria. If we remove
|attribute| from a global allow-list, we may also have to remove it from local remove-lists.

1. Set |attribute| to the result of [=canonicalize a sanitizer attribute=] with |attribute|.
1. If |configuration|["{{SanitizerConfig/attributes}}"] [=map/exists=]:
    1. [=Comment=]: If we have a global allow-list, we need to add |attribute|.
    1. If |configuration|["{{SanitizerConfig/attributes}}"] does not [=list/contain=] |attribute|:
        1. Return false.
    1. [=Comment=]: Fix-up per-element allow and remove lists.
    1. If |configuration|["{{SanitizerConfig/elements}}"] [=map/exists=]:
        1. [=list/iterate|For each=] |element| in |configuration|["{{SanitizerConfig/elements}}"]:
            1. If |element|["{{SanitizerElementNamespaceWithAttributes/removeAttributes}}"]
               [=map/with default=] &laquo; &raquo; [=list/contains=] |attribute|:
                1. [=list/Remove=] |attribute| from
                    |element|["{{SanitizerElementNamespaceWithAttributes/removeAttributes}}"].
    1. [=list/Remove=] |attribute| from |configuration|["{{SanitizerConfig/attributes}}"].
    1. Return true.
1. Otherwise:
    1. [=Comment=]: If we have a global remove-list, we need to add |attribute|.
    1. If |configuration|["{{SanitizerConfig/removeAttributes}}"] [=list/contains=] |attribute|
        return false.
    1. [=Comment=]: Fix-up per-element allow and remove lists.
    1. If |configuration|["{{SanitizerConfig/elements}}"] [=map/exists=]:
        1. [=list/iterate|For each=] |element| in |configuration|["{{SanitizerConfig/elements}}"]:
            1. If |element|["{{SanitizerElementNamespaceWithAttributes/attributes}}"]
               [=map/with default=] &laquo; &raquo; [=list/contains=] |attribute|:
                1. [=list/Remove=] |attribute| from
                    |element|["{{SanitizerElementNamespaceWithAttributes/attributes}}"].
            1. If |element|["{{SanitizerElementNamespaceWithAttributes/removeAttributes}}"]
               [=map/with default=] &laquo; &raquo; [=list/contains=] |attribute|:
                1. [=list/Remove=] |attribute| from
                    |element|["{{SanitizerElementNamespaceWithAttributes/removeAttributes}}"].
    1. [=list/Append=] |attribute| to |configuration|["{{SanitizerConfig/removeAttributes}}"]
    1. Return true.

</div>

<div algorithm>
To <dfn for="Sanitizer">set comments</dfn> with a [=boolean=] |allow| on a
{{SanitizerConfig}} |configuration|:

1. If |configuration|["{{SanitizerConfig/comments}}"] [=map/exists=] and
   |configuration|["{{SanitizerConfig/comments}}"] equals |allow|, then return false;
1. Set |configuration|["{{SanitizerConfig/comments}}"] to |allow|.
1. Return true.

</div>

<div algorithm>
To <dfn for="Sanitizer">set data attributes</dfn> with a [=boolean=] |allow|
on a {{SanitizerConfig}} |configuration|:

1. If |configuration|["{{SanitizerConfig/attributes}}"] does not [=map/exist=], then return false.
1. If |configuration|["{{SanitizerConfig/dataAttributes}}"] equals |allow|, then return false.
1. If |allow| is true:
   1. [=list/Remove=] any items |attr| from |configuration|["{{SanitizerConfig/attributes}}"]
       where |attr| is a [=custom data attribute=].
   1. If |configuration|["{{SanitizerConfig/elements}}"] [=map/exists=]:
      1. [=list/iterate|For each=] |element| in |configuration|["{{SanitizerConfig/elements}}"]:
         1. If |element|[{{SanitizerElementNamespaceWithAttributes/attributes}}] [=map/exists=]:
             1. [=list/Remove=] any items |attr| from
                 |element|[{{SanitizerElementNamespaceWithAttributes/attributes}}]
                 where |attr| is a [=custom data attribute=].
1. Set |configuration|["{{SanitizerConfig/dataAttributes}}"] to |allow|.
1. Return true.

</div>

<div algorithm>
To <dfn for="SanitizerConfig">remove unsafe</dfn> from a {{SanitizerConfig}} |configuration|,
do this:

Note: While this algorithm is called [=remove unsafe=], we use
    <a href="#security-considerations">the term "unsafe" strictly in the sense
    of this spec</a>, to denote content that will
    execute JavaScript when inserted into the document. In other words, this
    method will remove oportunities for XSS.

1. [=Assert=]: The [=map/get the keys|key set=] of [=built-in safe baseline configuration=]
   [=set/equals=]
   &laquo;[ "{{SanitizerConfig/removeElements}}", "{{SanitizerConfig/removeAttributes}}" ] &raquo;.
1. Let |result| be false.
1. [=list/For each=] |element| in
   [=built-in safe baseline configuration=][{{SanitizerConfig/removeElements}}]:
    1. Call [=Sanitizer/remove an element=] |element| from |configuration|.
    1. If the call returned true, set |result| to true.
1. [=list/For each=] |attribute| in
   [=built-in safe baseline configuration=][{{SanitizerConfig/removeAttributes}}]:
    1. Call [=Sanitizer/remove an attribute=] |attribute| from |configuration|.
    1. If the call returned true, set |result| to true.
1. [=list/For each=] |attribute| listed in [=event handler content attributes=]:
    1. Call [=Sanitizer/remove an attribute=] |attribute| from |configuration|.
    1. If the call returned true, set |result| to true.
1. Return |result|.

</div>


## Set the Configuration ## {#configuration-set}

<div algorithm>
To <dfn for="Sanitizer">set a configuration</dfn>, given a [=dictionary=] |configuration|,
a [=boolean=] |allowCommentsAndDataAttributes|, and a {{Sanitizer}} |sanitizer|:

1. [=Canonicalize the configuration|Canonicalize=] |configuration| with
    |allowCommentsAndDataAttributes|.
1. If |configuration| is not [=SanitizerConfig/valid=], then return false.
1. Set |sanitizer|'s [=Sanitizer/configuration=] to |configuration|.
1. Return true.

</div>

## Canonicalize the Configuration ## {#configuration-canonicalize}

The {{Sanitizer}} stores the [=Sanitizer/configuration=] in a canonical form, as this makes
a number of processing steps easier.

<div class=example>An {{SanitizerConfig/elements}} list `{elements: ["div"]}` gets stored as
`{elements: [{name: "div", namespace: "http://www.w3.org/1999/xhtml"}]`).
</div>

<div algorithm>
To <dfn for=Sanitizer>canonicalize the configuration</dfn> {{SanitizerConfig}} |configuration|
with a [=boolean=] |allowCommentsAndDataAttributes|:

Note: We assume that |configuration| is the result of [[WebIDL]] converting a JavaScript
value to a {{SanitizerConfig}}.

1. If neither |configuration|["{{SanitizerConfig/elements}}"] nor
    |configuration|["{{SanitizerConfig/removeElements}}"] [=map/exist=], then [=map/set=]
    |configuration|["{{SanitizerConfig/removeElements}}"] to &laquo; &raquo;.
1. If neither |configuration|["{{SanitizerConfig/attributes}}"] nor
    |configuration|["{{SanitizerConfig/removeAttributes}}"] [=map/exist=], then [=map/set=]
    |configuration|["{{SanitizerConfig/removeAttributes}}"] to &laquo; &raquo;.
1. If |configuration|["{{SanitizerConfig/elements}}"] [=map/exists=]:
   1. Let |elements| be &laquo; &raquo;.
   1. [=list/iterate|For each=] |element| of |configuration|["{{SanitizerConfig/elements}}"] do:
      1. [=list/Append=] the result of [=canonicalize a sanitizer element with attributes=]
          |element| to |elements|.
   1. Set |configuration|["{{SanitizerConfig/elements}}"] to |elements|.
1. If |configuration|["{{SanitizerConfig/removeElements}}"] [=map/exists=]:
   1. Let |elements| be &laquo; &raquo;.
   1. [=list/iterate|For each=] |element| of |configuration|["{{SanitizerConfig/removeElements}}"] do:
      1. [=list/Append=] the result of [=canonicalize a sanitizer element=] |element| to
          |elements|.
   1. Set |configuration|["{{SanitizerConfig/removeElements}}"] to |elements|.
1. If |configuration|["{{SanitizerConfig/replaceWithChildrenElements}}"] [=map/exists=]:
   1. Let |elements| be &laquo; &raquo;.
   1. [=list/iterate|For each=] |element| of |configuration|["{{SanitizerConfig/replaceWithChildrenElements}}"] do:
      1. [=list/Append=] the result of [=canonicalize a sanitizer element=] |element| to |elements|.
   1. Set |configuration|["{{SanitizerConfig/replaceWithChildrenElements}}"] to |elements|.
1. If |configuration|["{{SanitizerConfig/attributes}}"] [=map/exists=]:
   1. Let |attributes| be &laquo; &raquo;.
   1. [=list/iterate|For each=] |attribute| of |configuration|["{{SanitizerConfig/attributes}}"] do:
      1. [=list/Append=] the result of [=canonicalize a sanitizer attribute=] |attribute| to
          |attributes|.
   1. Set |configuration|["{{SanitizerConfig/attributes}}"] to |attributes|.
1. If |configuration|["{{SanitizerConfig/removeAttributes}}"] [=map/exists=]:
   1. Let |attributes| be &laquo; &raquo;.
   1. [=list/iterate|For each=] |attribute| of |configuration|["{{SanitizerConfig/removeAttributes}}"] do:
      1. [=list/Append=] the result of [=canonicalize a sanitizer attribute=] |attribute| to
          |attributes|.
   1. Set |configuration|["{{SanitizerConfig/removeAttributes}}"] to |attributes|.
1. If |configuration|["{{SanitizerConfig/comments}}"] does not [=map/exist=], then [=map/set=]
    |configuration|["{{SanitizerConfig/comments}}"] to |allowCommentsAndDataAttributes|.
1. If |configuration|["{{SanitizerConfig/attributes}}"] [=map/exists=] and
    |configuration|["{{SanitizerConfig/dataAttributes}}"] does not [=map/exist=], then
    [=map/set=] |configuration|["{{SanitizerConfig/dataAttributes}}"] to
    |allowCommentsAndDataAttributes|.

</div>

<div algorithm>
To <dfn>canonicalize a sanitizer element with attributes</dfn> a {{SanitizerElementWithAttributes}} |element|:

1. Let |result| be the result of [=canonicalize a sanitizer element=] with |element|.
1. If |element| is a [=dictionary=]:
  1. If |element|["{{SanitizerElementNamespaceWithAttributes/attributes}}"] [=map/exists=]:
    1. Let |attributes| be &laquo; &raquo;.
    1. [=list/iterate|For each=] |attribute| of |element|["{{SanitizerElementNamespaceWithAttributes/attributes}}"]:
      1. [=list/Append=] the result of [=canonicalize a sanitizer attribute=] with |attribute| to |attributes|.
    1. [=map/Set=] |result|["{{SanitizerElementNamespaceWithAttributes/attributes}}"] to |attributes|.
  1. If |element|["{{SanitizerElementNamespaceWithAttributes/removeAttributes}}"] [=map/exists=]:
    1. Let |attributes| be &laquo; &raquo;.
    1. [=list/iterate|For each=] |attribute| of |element|["{{SanitizerElementNamespaceWithAttributes/removeAttributes}}"]:
      1. [=list/Append=] the result of [=canonicalize a sanitizer attribute=] with |attribute| to |attributes|.
    1. [=map/Set=] |result|["{{SanitizerElementNamespaceWithAttributes/removeAttributes}}"] to |attributes|.
1. If neither |result|["{{SanitizerElementNamespaceWithAttributes/attributes}}"] nor
   |result|["{{SanitizerElementNamespaceWithAttributes/removeAttributes}}"] [=map/exist=]:
  1. [=map/Set=] |result|["{{SanitizerElementNamespaceWithAttributes/removeAttributes}}"] to &laquo; &raquo;.
1. Return |result|.

</div>

<div algorithm>
In order to <dfn>canonicalize a sanitizer element</dfn> a
{{SanitizerElement}} |element|,
return the result of [=canonicalize a sanitizer name=] with |element| and the [=HTML namespace=] as the default namespace.
</div>

<div algorithm>
In order to <dfn>canonicalize a sanitizer attribute</dfn> a
{{SanitizerAttribute}} |attribute|,
return the result of [=canonicalize a sanitizer name=] with |attribute| and null as the default namespace.
</div>

<div algorithm>
In order to <dfn>canonicalize a sanitizer name</dfn> |name|, with a default
namespace |defaultNamespace|, run the following steps:

1. [=Assert=]: |name| is either a {{DOMString}} or a [=dictionary=].
1. If |name| is a {{DOMString}}, then return &laquo;[ "`name`" &rightarrow; |name|, "`namespace`" &rightarrow; |defaultNamespace|]&raquo;.
1. [=Assert=]: |name| is a [=dictionary=] and both |name|["name"] and |name|["namespace"] [=map/exist=].
1. If |name|["namespace"] is the empty string, then set it to null.
1. Return &laquo;[ <br>
  "`name`" &rightarrow; |name|["name"], <br>
  "`namespace`" &rightarrow; |name|["namespace"] <br>
  ]&raquo;.

</div>

## Supporting Algorithms ## {#alg-support}

For the [=canonicalize a sanitizer name|canonicalized=]
{{SanitizerElementNamespace|element}} and {{SanitizerAttributeNamespace|attribute name}} lists
used in this spec, list membership is based on matching both "`name`" and "`namespace`"
entries:

<div algorithm>
A Sanitizer name |list| <dfn for="SanitizerConfig">contains</dfn> an |item|
if there exists an |entry| of |list| that is an [=ordered map=], and where
|item|["name"] [=string/is|equals=] |entry|["name"] and
|item|["namespace"] [=string/is|equals=] |entry|["namespace"].
</div>

<div algorithm>
To <dfn for="SanitizerConfig">remove</dfn> an |item| from a |list| that is an
[=ordered map=], [=list/remove=] all |entry| from |list|
where |item|["name"] [=string/is|equals=] |entry|["name"] and
|item|["namespace"] [=string/is|equals=] |entry|["namespace"].
</div>

<div algorithm>
To <dfn for="SanitizerConfig">add</dfn> a |name| to a |list|, where |name| is
[=canonicalize a sanitizer name|canonicalized=] and |list| is an [=ordered map=]:

1. If |list| [=SanitizerConfig/contains=] |name|, then return.
1. [=list/Append=] |name| to |list|.

</div>

<div algorithm>
An item |itemA| is <dfn for="SanitizerConfig">less than item</dfn> |itemB| if:

1. If |itemA|["namespace"] is null:
    1. If |itemB|["namespace"] is not null, return true.
1. Otherwise:
    1. If |itemB|["namespace"] is null, return false.
    1. If |itemA|["namespace"] is [=/code unit less than=] |itemB|["namespace"], return true.
1. Return |itemA|["name"] is [=/code unit less than=]|itemB|["name"].

</div>

<div algorithm>
Equality for [=ordered sets=] is equality of its members, but without
regard to order:
[=Ordered sets=] |A| and |B| are <dfn for=set>equal</dfn> if both |A| is a
[=superset=] of |B| and |B| is a [=superset=] of |A|.
</div>

<div algorithm>
An  [=ordered map=] is a sequence of [=map/key=] and [=map/value=] [=tuples=].
Equality of [=ordered maps=] is equality of this sequence of tuples, when treated as an ordered
set.
[=Ordered maps=] |A| and |B| are <dfn for=map>equal</dfn> if the [=ordered set=] consisting
of |A|'s [=map/entries=] and the [=ordered set=] of |B|'s [=map/entries=] are [=set/equal=].
</div>

<div algorithm>
A [=/list=] |list| <dfn for=SanitizerConfig>has duplicates</dfn>,
if [=list/iterate|for any=] |item| of |list|,
there is more than one |entry| in |list| where
|item|["name"] is |entry|["name"] and
|item|["namespace"] is |entry|["namespace"].
</div>

<div algorithm>
To <dfn for=SanitizerConfig>remove duplicates</dfn> from a [=/list=] |list|,

1. Let |result| be &laquo; &raquo;.
1. [=list/iterate|For each=] |entry| of |list|, [=SanitizerConfig/add=] |entry| to |result|.
1. Return |result|.

</div>

<div algorithm>
The <dfn for=SanitizerConfig>intersection</dfn> of two [=/lists=] |A| and |B|
containing {{SanitizerElement}} is the same as [=set/intersection|set intersection=],
but with the [=/set=] entries previously [=canonicalize a sanitizer name|canonicalized=]:

1. Let |set A| be &laquo; [] &raquo;
1. Let |set B| be &laquo; [] &raquo;
1. [=list/iterate|For each=] |entry| of |A|, [=set/append=] the result of
    [=canonicalize a sanitizer name=] |entry| to |set A|.
1. [=list/iterate|For each=] |entry| of |B|, [=set/append=] the result of
    [=canonicalize a sanitizer name=] |entry| to |set B|.
1. Retrun the [=set/intersection=] of |set A| and |set B|.

</div>

<div algorithm>
To determine <dfn for="boolean">not</dfn> of a [=boolean=] |bool|,
return false if |bool| is true, and return true otherwise.
</div>

<div>
A <dfn>Comment</dfn> contains an explanatory text that applies to a particular
point within an algorithm.
</div>

## Builtins ## {#sanitization-defaults}

There are four builtins:

* The [=built-in safe default configuration=],
* the [=built-in safe baseline configuration=], and
* the [=built-in navigating URL attributes list=], and
* the [=built-in animating URL attributes list=].

The <dfn>built-in safe default configuration</dfn> is as follows:

<pre class="include-code">
path: builtins/safe-default-configuration.json
highlight: json
</pre>

Note: Included [[MathML]] markup is based on [[SafeMathML]].

The <dfn>built-in safe baseline configuration</dfn> is meant to block only
script-content. It is as follows:

<pre class="include-code">
path: builtins/safe-baseline-configuration.json
highlight: json
</pre>

<div class="advisement">
<!-- When included in HTML, this should probably read as class="warning". -->

<strong class="marker">Warning:</strong> The [=remove unsafe=] algorithm specifies
to additionally remove any [=event handler content attributes=], as defined
in [[HTML]].
If a [=user agent=] defines extensions to the [[HTML]] spec with additional
[=event handler content attributes=], it is its responsibility to decide how
to handle them. Using the current [=event handler content attributes=] list,
the safe baseline configuration looks effectively like so:

<pre class="include-code">
path: builtins/safe-baseline-configuration-materialized.json
highlight: json
</pre>

</div>

<div>
The <dfn>built-in navigating URL attributes list</dfn>, for which "`javascript:`"
navigations are "unsafe", are as follows:

&laquo;[
  <br>
  [
    { "`name`" &rightarrow; "`a`", "`namespace`" &rightarrow; [=HTML namespace=] },
    { "`name`" &rightarrow; "`href`", "`namespace`" &rightarrow; `null` }
  ],
  <br>
  [
    { "`name`" &rightarrow; "`area`", "`namespace`" &rightarrow; [=HTML namespace=] },
    { "`name`" &rightarrow; "`href`", "`namespace`" &rightarrow; `null` }
  ],
  <br>
  [
    { "`name`" &rightarrow; "`base`", "`namespace`" &rightarrow; [=HTML namespace=] },
    { "`name`" &rightarrow; "`href`", "`namespace`" &rightarrow; `null` }
  ],
  <br>
  [
    { "`name`" &rightarrow; "`button`", "`namespace`" &rightarrow; [=HTML namespace=] },
    { "`name`" &rightarrow; "`formaction`", "`namespace`" &rightarrow; `null` }
  ],
  <br>
  [
    { "`name`" &rightarrow; "`form`", "`namespace`" &rightarrow; [=HTML namespace=] },
    { "`name`" &rightarrow; "`action`", "`namespace`" &rightarrow; `null` }
  ],
  <br>
  [
    { "`name`" &rightarrow; "`iframe`", "`namespace`" &rightarrow; [=HTML namespace=] },
    { "`name`" &rightarrow; "`src`", "`namespace`" &rightarrow; `null` }
  ],
  <br>
  [
    { "`name`" &rightarrow; "`input`", "`namespace`" &rightarrow; [=HTML namespace=] },
    { "`name`" &rightarrow; "`formaction`", "`namespace`" &rightarrow; `null` }
  ],
  <br>
  [
    { "`name`" &rightarrow; "`a`", "`namespace`" &rightarrow; [=SVG namespace=] },
    { "`name`" &rightarrow; "`href`", "`namespace`" &rightarrow; `null` }
  ],
  <br>
  [
    { "`name`" &rightarrow; "`a`", "`namespace`" &rightarrow; [=SVG namespace=] },
    { "`name`" &rightarrow; "`href`", "`namespace`" &rightarrow; [=XLink namespace=] }
  ],
  <br>
]&raquo;
</div>

The <dfn>built-in animating URL attributes list</dfn>, which can be used in
[[SVG11]] to declaratively modify navigation elements to use "`javascript:`"
URLs, is as follows:

&laquo;[
  <br>
  [
    { "`name`" &rightarrow; "`animate`", "`namespace`" &rightarrow; [=SVG namespace=] },
    { "`name`" &rightarrow; "`attributeName`", "`namespace`" &rightarrow; `null`] }
  ],
  <br>
  [
    { "`name`" &rightarrow; "`animateMotion`", "`namespace`" &rightarrow; [=SVG namespace=] },
    { "`name`" &rightarrow; "`attributeName`", "`namespace`" &rightarrow; `null` }
  ],
  <br>
  [
    { "`name`" &rightarrow; "`animateTransform`", "`namespace`" &rightarrow; [=SVG namespace=] },
    { "`name`" &rightarrow; "`attributeName`", "`namespace`" &rightarrow; `null` }
  ],
  <br>
  [
    { "`name`" &rightarrow; "`set`", "`namespace`" &rightarrow; [=SVG namespace=] },
    { "`name`" &rightarrow; "`attributeName`", "`namespace`" &rightarrow; `null` }
  ],
  <br>
]&raquo;

# Security Considerations # {#security-considerations}

The Sanitizer API is intended to prevent DOM-based Cross-Site Scripting
by traversing a supplied HTML content and removing elements and attributes
according to a configuration. The specified API must not support
the construction of a Sanitizer object that leaves script-capable markup in
and doing so would be a bug in the threat model.

That being said, there are security issues which the correct usage of the
Sanitizer API will not be able to protect against and the scenarios will be
laid out in the following sections.

## Server-Side Reflected and Stored XSS ## {#server-side-xss}

<em>This section is not normative.</em>

The Sanitizer API operates solely in the DOM and adds a capability to traverse
and filter an existing DocumentFragment. The Sanitizer does not address
server-side reflected or stored XSS.

## DOM clobbering ## {#dom-clobbering}

<em>This section is not normative.</em>

DOM clobbering describes an attack in which malicious HTML confuses an
application by naming elements through `id` or `name` attributes such that
properties like `children` of an HTML element in the DOM are overshadowed by
the malicious content.

The Sanitizer API does not protect DOM clobbering attacks in its
default state, but can be configured to remove `id` and `name` attributes.

## XSS with Script gadgets ## {#script-gadgets}

<em>This section is not normative.</em>

Script gadgets are a technique in which an attacker uses existing application
code from popular JavaScript libraries to cause their own code to execute.
This is often done by injecting innocent-looking code or seemingly inert
DOM nodes that is only parsed and interpreted by a framework which then
performs the execution of JavaScript based on that input.

The Sanitizer API can not prevent these attacks, but requires page authors to
explicitly allow unknown elements in general, and authors must additionally
explicitly configure unknown attributes and elements and markup that is known
to be widely used for templating and framework-specific code,
like `data-` and `slot` attributes and elements like `<slot>` and `<template>`.
We believe that these restrictions are not exhaustive and encourage page
authors to examine their third party libraries for this behavior.

## Mutated XSS ## {#mutated-xss}

<em>This section is not normative.</em>

Mutated XSS or mXSS describes an attack based on parser context mismatches
when parsing an HTML snippet without the correct context. In particular,
when a parsed HTML fragment has been serialized to a string, the string is
not guaranteed to be parsed and interpreted exactly the same when inserted
into a different parent element. An example for carrying out such an attack
is by relying on the change of parsing behavior for foreign content or
mis-nested tags.

The Sanitizer API offers only functions that turn a string into a node tree.
The context is supplied implicitly by all sanitizer functions:
`Element.setHTML()` uses the current element; `Document.parseHTML()` creates a
new document. Therefore Sanitizer API is not directly affected by mutated XSS.

If a developer were to retrieve a sanitized node tree as a string, e.g. via
`.innerHTML`, and to then parse it again then mutated XSS may occur.
We discourage this practice. If processing or passing of HTML as a
string should be necessary after all, then any string should be considered
untrusted and should be sanitized (again) when inserting it into the DOM. In
other words, a sanitized and then serialized HTML tree can no
longer be considered as sanitized.

A more complete treatment of mXSS can be found in [[MXSS]].

# Acknowledgements # {#ack}

This work is informed and inspired by [[DOMPURIFY]] from cure53,
Internet Explorer's {{window.toStaticHTML()}} as well as the original
[[HTMLSanitizer]] from Ben Bucksch.
Anne van Kesteren, Krzysztof Kotowicz, Tom Schuster, Luke Warlow,
Guillaume Weghsteen, and Mike West for their valuable feedback.
